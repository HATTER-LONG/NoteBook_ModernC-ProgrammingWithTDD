# 总结

- TDD 的践行步骤：
  1. 编译一个最基本单元功能的测试代码。
  2. 测试失败。
  3. 实现功能代码**最低限度**使得测试代码通过。
  4. 测试成功。
  5. goto ⬆ 第一步。
  6. TDD 的各个周期都会使用重构来审阅设计。

## 践行步骤解析

- 编写最基本的单元功能测试代码：请谨记我们践行的是 TDD，而非单纯的测试工作，应该测试的是代码行为，当向测试代码添加重复的断言语句时应该自问下这个断言是否可以提升对测试含义以及功能的理解。

- 测试失败：每次以最小的步伐向前推进，引起问题后就去解决掉它。

- 实现功能代码最低限度的使得测试代码通过：
  - `最低限度` 即刚刚好满足测试用例所需要的功能，即使是通过特例来完成的。就像 Soundex 中出现过多次特例一样，经常使用特例的方法来快速通过测试代码。
  - 但是请注意特例也不是万能的，就像文档中我所讲的 **不要使用已有的处理逻辑**，避免使用大量的特例浪费时间，当第二次添加的测试用例，就不可以再使用上一次一样的特例方法了，应该寻求更加通用的实现方法。这一步不仅仅是重构，也是作为我们代码开发前进的动力，是对行为的一种完善。

- 测试成功：必然保证之前失败的用例要正确的通过，且没有影响已有的用例。

- 审视代码进行重构：重构不仅仅是某个单一步骤执行，而是当历经 TDD 的各个周期时，我们会使用重构来审阅设计，同时修复出现的所有问题。重构的主要关注点是提升表达能力，去除重复代码。就代码的可维护性来说，这两个点最有裨益。

## TDD Q&A

有时也会担心一些实现的细节并不是那么好，是否应该再重构是考虑优化？

再未完全实现功能设计之前，这些都属于过早优化。这个时候一个好的设计更重要，一旦以牢靠的设计实现了正确的行为后，并且有完整的单元测试来给你提供勇气后再进行优化吧！

-----------------------------

没有被单元测试代码所描述的行为算正确还是错误？

任何时候，一个完整的测试集合声明了系统中期望的行为。这里蕴含着一个潜台词：如果一个行为没有对应的测试来描述，那这个行为要么不存在，要么不是期望的（或者测试本身没有尽到描述行为的职责）。

-----------------------------

对于有大量的数据细节测试，例如 Soundex 中的辅音表，是否需要将所有的表信息都进行单元测试覆盖？

请注意我们实在进行`测试驱动开发`，而非测试。TDD 着力于代码设计。测试主要用于表述你要构建的行为。TDD 过程中编写的测试大都是这个流程的附属产物。有了这些测试，在接下来改动代码时，你会更有信心。而且 TDD 的一个重要方面就是够用即可，在开发新功能即行为时，编写测试覆盖，而逻辑代码不在改变时，就不用编写测试代码了。

也就是说如果你读取这个表数据的行为单一，那么它就不需要全部都覆盖到。
