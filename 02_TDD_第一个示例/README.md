# 总结

- [总结](#总结)
  - [践行步骤解析](#践行步骤解析)
  - [TDD Q&A](#tdd-qa)

- TDD 的践行步骤：
  1. 编译一个最基本单元功能的测试代码。
  2. 测试失败。
  3. 实现功能代码**最低限度**使得测试代码通过。
  4. 测试成功。
  5. goto ⬆ 第一步。
  6. TDD 的各个周期都会使用重构来审阅设计。

## 践行步骤解析

- 编写最基本的单元功能测试代码：请谨记我们践行的是 TDD，而非单纯的测试工作，应该测试的是代码行为，当向测试代码添加重复的断言语句时应该自问下这个断言是否可以提升对测试含义以及功能的理解。

- 测试失败：每次以最小的步伐向前推进，引起问题后就去解决掉它。

- 实现功能代码最低限度的使得测试代码通过：
  - `最低限度` 即刚刚好满足测试用例所需要的功能，即使是通过特例来完成的。就像 Soundex 中出现过多次特例一样，经常使用特例的方法来快速通过测试代码。
  - 但是请注意特例也不是万能的，就像文档中我所讲的 **不要使用已有的处理逻辑**，避免使用大量的特例浪费时间，当第二次添加的测试用例，就不可以再使用上一次一样的特例方法了，应该寻求更加通用的实现方法。这一步不仅仅是重构，也是作为我们代码开发前进的动力，是对行为的一种完善。

- 测试成功：必然保证之前失败的用例要正确的通过，且没有影响已有的用例。

- 审视代码进行重构：重构不仅仅是某个单一步骤执行，而是当历经 TDD 的各个周期时，我们会使用重构来审阅设计，同时修复出现的所有问题。重构的主要关注点是提升表达能力，去除重复代码。就代码的可维护性来说，这两个点最有裨益。

- 一次只进行一件事：当发现一个行为的实现可能需要先重构下代码才能更方便的支持，那么就要先将这个行为失败的测试描述先注释掉。当完成重构后再打开并完成。**一次只做一件事。测试驱动开发时，要保持每一步都不同**。再写测试时，不要跑去重构。同样，在尝试让测试通过时也不要去重构。

- 如果出现并未主动实现对应行为代码，新增加的测试用例确成功了这时就要警惕：如果接下来的测试也都继续通过，那么应该考虑回滚掉代码改动。测试提前通过的原因，可能是你的步伐有点大，但这样你可能不会感受到 TDD 带来的好处。

-----------------------------------

- 一个解决方案应具备的一些重要特征。
  - 它实现了客户的需求。如果没有，那么不管怎样，它都不是好的解决方案。在TDD中，你编写的测试能够帮助你了解你的解决方案是不是客户要的。性能可能是众多客户需求中的一项。你的一部分职责就是理解他们的性能需求，如果没必要的话，就不要花费时间去做性能优化。
  - 它可以工作。如果一个解决方案有大量的缺陷，那么构建得再优雅，也不是好的解决方案。TDD可以帮助确定我们交付的软件能以期望的方式工作。TDD不是银弹。你交付的软件依然会有缺陷，所以照样需要许多其他方式的测试。但是，TDD会让你发布的代码包含非常少的缺陷。
  - 它易于理解。对于编写得不好的代码，每个人都需要花费大量的时间去理解。TDD让你可以安全地重新组织代码以提高可读性。
  - 它易于修改。通常，容易修改的代码意味着高质量的设计。TDD使你可以持续地修改，以保持设计的高质量。

## TDD Q&A

1. 有时也会担心一些实现的细节并不是那么好，是否应该再重构是考虑优化？
   - 再未完全实现功能设计之前，这些都属于过早优化。这个时候一个好的设计更重要，一旦以牢靠的设计实现了正确的行为后，并且有完整的单元测试来给你提供勇气后再进行优化吧！

2. 没有被单元测试代码所描述的行为算正确还是错误？
   - 任何时候，一个完整的测试集合声明了系统中期望的行为。这里蕴含着一个潜台词：如果一个行为没有对应的测试来描述，那这个行为要么不存在，要么不是期望的（或者测试本身没有尽到描述行为的职责）。

3. 对于有大量的数据细节测试，例如 Soundex 中的辅音表，是否需要将所有的表信息都进行单元测试覆盖？
   - 请注意我们实在进行`测试驱动开发`，而非测试。TDD 着力于代码设计。测试主要用于表述你要构建的行为。TDD 过程中编写的测试大都是这个流程的附属产物。有了这些测试，在接下来改动代码时，你会更有信心。而且 TDD 的一个重要方面就是够用即可，在开发新功能即行为时，编写测试覆盖，而逻辑代码不在改变时，就不用编写测试代码了。
   - 也就是说如果你读取这个表数据的行为单一，那么它就不需要全部都覆盖到。
