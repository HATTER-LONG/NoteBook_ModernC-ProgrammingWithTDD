# 测试驱动开发：第一个示例

- [测试驱动开发：第一个示例](#测试驱动开发第一个示例)
  - [前言](#前言)
  - [Soundex 类](#soundex-类)
  - [Let's start](#lets-start)
  - [去掉不干净的代码](#去掉不干净的代码)
    - [命名空间的修复](#命名空间的修复)
    - [消除重复代码](#消除重复代码)
  - [增量性](#增量性)

## 前言

写个测试，保证它通过，接着重构设计，这就是 TDD 的全部内容了。

## Soundex 类

以 TDD 的方式开发 Soundex 类，这种类可以提升应用程序的搜索能力。这个算法是将单词编码为一个字母和三个数字，它将发音相似的单词映射到相同的编码。[Wiki 解释](http://en.wikipedia.org/wiki/Soundex)：

1. 保留第一个字母。丢掉所有出现的 a、e、i、o、 u、y、h、w。
2. 以数字来代替辅音（第一个字母除外）：
   - b、f、p、v : 1
   - c、g、j、k、q、s、x、z : 2
   - d、t : 3
   - l : 4
   - m、n : 5
   - r : 6

3. 如果相邻字母编码相同，用一个数字表示它们即可。同样，如果出现两个编码相同的字母，且它们被h或w隔开，也这样处理；但如果被元音隔开，就要编码两次。这条规则同样适用于第一个字母。
4. 当得到一个字母和三个数字时，停止处理。如果需要，补零以对齐。

## Let's start

TDD 并非一次将所有测试全部实现，而是每次只关注一个功能点对应的单元测试，当完成后再考虑下一个需要加入系统的功能。

**从宏观的角度来看，TDD 的践行步骤是：编写一个最基本单元功能的测试代码 --> 测试失败 --> 实现功能代码最低限度的使得测试代码通过测试 --> 测试成功 --> 考虑下一个基本单元功能并编写对应测试 --> ...。**

基于这一思路，以 Soundex 举例：最先需要实现的便是步骤一，保留第一个字母：

```cpp
#include "catch2/catch.hpp"

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var") { Soundex soundex; }
}
```

- 我们创建了一个 Soundex 一个对象，然后到此为止，因为现在已经编译不通过了，需要先解决这个问题：
  - 只在为了使失败测试通过时才编写产品代码。
  - 当测试刚好失败时，停止继续编写。编译失败也是失败。
  - 只编写刚好能让一个失败测试通过的产品代码。

现在编译在已经通知未定义 Soundex 的错误：

```cpp
#include "catch2/catch.hpp"

// TODO : 当前暂时与测试代码同一个文件，当感觉代码放在同一个文件有些麻烦时，再用合适的方式迁出
/**
 * @brief 实现 Soundex 类
 *
 */
class Soundex
{
};

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var") { Soundex soundex; }
}
```

现在继续向前添加功能，设计使 Soundex 对外提供一个 encode(string) 公共成员函数，现在代码使无法编译通过：
  
```cpp
...
TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char") { auto encoded = soundex.encode("A"); }
    }
}
...
```

修复错误，使 Soundex 支持 encode 方法：

```cpp
/**
 * @brief Soundex 算法类
 *
 */
class Soundex
{
public:
    /**
     * @brief 按照 Soundex 算法转换输入的字符串内容
     * 
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& word) const { return ""; }
};
```

现在检验返回值是否符合 Soundex 算法转换后的结果：

```cpp
...
       WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Catch::Equals("A")); }
        }
...
```

现在得到了与前边编译失败不同的结果，断言失败。当然这时必然的，因为 encode 方法并没有什么实现。

```c++
/**
 * @brief Soundex 算法类
 *
 */
class Soundex
{
public:
    /**
     * @brief 按照 Soundex 算法转换输入的字符串内容
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return "A"; }
};
```

现在断言能通过了，不过功能并没有完善，不过这里展示了一个渐进式 TDD 开发的过程。

## 去掉不干净的代码

即使代码很短也可能存在问题，TDD 为开发提供了更好的时机区修复，便是每次完成单元测试代码以及功能代码编写完成后都可以进行快速的增量审阅，避免小问题越积越多。

### 命名空间的修复

单元测试代码中，Equals 使用 Catch 命名空间比较影响阅读连贯性，使用命名空间将断言读起来像一个句子：

```cpp
#include "catch2/catch.hpp"

using namespace Catch;

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A")); }
        }
    }
}
```

### 消除重复代码

重复代码对于维护成本和风险都会提升。审阅代码是需要着重优化。

在此例中没有太明显的重复，但是 `"A"` 这个硬编码的字符串出现了很多回，可以将 encode 方法中返回的硬编码 "A" 优化以下：

```cpp
/**
 * @brief Soundex 算法类
 *
 */
class Soundex
{
public:
    /**
     * @brief 按照 Soundex 算法转换输入的字符串内容
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return Word; }
};
```

任何时候，一个完整的测试集合声明了系统中期望的行为。这里蕴含着一个潜台词：如果一个行为没有对应的测试来描述，那这个行为要么不存在，要么不是期望的（或者测试本身没有尽到描述行为的职责）。

当历经TDD的各个周期时，我们会使用重构来审阅设计，同时修复出现的所有问题。重构的主要关注点是提升表达能力，去除重复代码。就代码的可维护性来说，这两个点最有裨益。

## 增量性