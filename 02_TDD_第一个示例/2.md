# 测试驱动开发：第一个示例

- [测试驱动开发：第一个示例](#测试驱动开发第一个示例)
  - [前言](#前言)
  - [Soundex 类](#soundex-类)
  - [Let's start](#lets-start)
  - [去掉不干净的代码](#去掉不干净的代码)
    - [命名空间的修复](#命名空间的修复)
    - [消除重复代码](#消除重复代码)
  - [增量性](#增量性)
  - [fixture 与设置](#fixture-与设置)

## 前言

写个测试，保证它通过，接着重构设计，这就是 TDD 的全部内容了。

## Soundex 类

以 TDD 的方式开发 Soundex 类，这种类可以提升应用程序的搜索能力。这个算法是将单词编码为一个字母和三个数字，它将发音相似的单词映射到相同的编码。[Wiki 解释](http://en.wikipedia.org/wiki/Soundex)：

1. 保留第一个字母。丢掉所有出现的 a、e、i、o、 u、y、h、w。
2. 以数字来代替辅音（第一个字母除外）：
   - b、f、p、v : 1
   - c、g、j、k、q、s、x、z : 2
   - d、t : 3
   - l : 4
   - m、n : 5
   - r : 6

3. 如果相邻字母编码相同，用一个数字表示它们即可。同样，如果出现两个编码相同的字母，且它们被h或w隔开，也这样处理；但如果被元音隔开，就要编码两次。这条规则同样适用于第一个字母。
4. 当得到一个字母和三个数字时，停止处理。如果需要，补零以对齐。

## Let's start

TDD 并非一次将所有测试全部实现，而是每次只关注一个功能点对应的单元测试，当完成后再考虑下一个需要加入系统的功能。

**从宏观的角度来看，TDD 的践行步骤是：编写一个最基本单元功能的测试代码 --> 测试失败 --> 实现功能代码最低限度的使得测试代码通过测试 --> 测试成功 --> 考虑下一个基本单元功能并编写对应测试 --> ...。**

基于这一思路，以 Soundex 举例：最先需要实现的便是步骤一，保留第一个字母：

```cpp
#include "catch2/catch.hpp"

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var") { Soundex soundex; }
}
```

- 我们创建了一个 Soundex 一个对象，然后到此为止，因为现在已经编译不通过了，需要先解决这个问题：
  - 只在为了使失败测试通过时才编写产品代码。
  - 当测试刚好失败时，停止继续编写。编译失败也是失败。
  - 只编写刚好能让一个失败测试通过的产品代码。

现在编译在已经通知未定义 Soundex 的错误：

```cpp
#include "catch2/catch.hpp"

// TODO : 当前暂时与测试代码同一个文件，当感觉代码放在同一个文件有些麻烦时，再用合适的方式迁出
/**
 * @brief 实现 Soundex 类
 *
 */
class Soundex
{
};

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var") { Soundex soundex; }
}
```

现在继续向前添加功能，设计使 Soundex 对外提供一个 encode(string) 公共成员函数，现在代码使无法编译通过：
  
```cpp
...
TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char") { auto encoded = soundex.encode("A"); }
    }
}
...
```

修复错误，使 Soundex 支持 encode 方法：

```cpp
/**
 * @brief Soundex 算法类
 *
 */
class Soundex
{
public:
    /**
     * @brief 按照 Soundex 算法转换输入的字符串内容
     * 
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& word) const { return ""; }
};
```

现在检验返回值是否符合 Soundex 算法转换后的结果：

```cpp
...
       WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Catch::Equals("A")); }
        }
...
```

现在得到了与前边编译失败不同的结果，断言失败。当然这时必然的，因为 encode 方法并没有什么实现。

```c++
/**
 * @brief Soundex 算法类
 *
 */
class Soundex
{
public:
    /**
     * @brief 按照 Soundex 算法转换输入的字符串内容
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return "A"; }
};
```

现在断言能通过了，不过功能并没有完善，不过这里展示了一个渐进式 TDD 开发的过程。

## 去掉不干净的代码

即使代码很短也可能存在问题，TDD 为开发提供了更好的时机区修复，便是每次完成单元测试代码以及功能代码编写完成后都可以进行快速的增量审阅，避免小问题越积越多。

### 命名空间的修复

单元测试代码中，Equals 使用 Catch 命名空间比较影响阅读连贯性，使用命名空间将断言读起来像一个句子：

```cpp
#include "catch2/catch.hpp"

using namespace Catch;

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A")); }
        }
    }
}
```

### 消除重复代码

重复代码对于维护成本和风险都会提升。审阅代码是需要着重优化。

在此例中没有太明显的重复，但是 `"A"` 这个硬编码的字符串出现了很多回，可以将 encode 方法中返回的硬编码 "A" 优化以下：

```cpp
/**
 * @brief Soundex 算法类
 *
 */
class Soundex
{
public:
    /**
     * @brief 按照 Soundex 算法转换输入的字符串内容
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return Word; }
};
```

任何时候，一个完整的测试集合声明了系统中期望的行为。这里蕴含着一个潜台词：如果一个行为没有对应的测试来描述，那这个行为要么不存在，要么不是期望的（或者测试本身没有尽到描述行为的职责）。

当历经TDD的各个周期时，我们会使用重构来审阅设计，同时修复出现的所有问题。重构的主要关注点是提升表达能力，去除重复代码。就代码的可维护性来说，这两个点最有裨益。

## 增量性

对于前文的硬编码可能心存疑虑，但是我们都很清楚硬编码最多存在一小会，随着对目标描述而编写更多的测试用例，逐渐就会替换掉硬编码。

继续完善 Soundex 功能，对于现在的代码并不符 Soundex 规范，以只传递单个字符为前提，并不符合第四条即如果没有三个数字，需要补零。接下来为这个功能编写新的测试。

```cpp
TEST_CASE("Pads with zeros to ensure three digits", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("I");
            THEN("Check that the return value pads with zeros") { REQUIRE_THAT(encoded, Equals("I000")); }
        }
    }
}
```

失败了：

```shell
/home/caolei/WorkSpace/TDD_Learning/test/Catch2/TestSoundex.cpp:45: FAILED:
  REQUIRE_THAT( encoded, Equals("I000") )
with expansion:
  "I" equals: "I000"

===============================================================================
test cases: 2 | 1 passed | 1 failed
assertions: 2 | 1 passed | 1 failed

```

让测试通过：

```cpp
/**
 * @brief 按照 Soundex 算法转换输入的字符串内容
 *
 * @param word
 * @return std::string
 */
std::string encode(const std::string& Word) const { return Word + "000"; }
```

这时会发现第一条用例失败了，这时因为第一条用例与 Soundex 的规则不符合，修改其断言语句已适配规则：

```cpp
TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A000")); }
        }
    }
}
```

现在有两条相似的测试仅仅数据有些差异，但是没有关系，每个测试描述一种行为。**我们不仅要确保系统按预期工作，还要让每个人知道所有既定的系统行为。**

完整这个功能周期后，考虑重构代码。可以发现 encode 的实现有些让人迷惑，尤其是不清楚条款的人看到这种魔数组合，因此需要对齐封装下，提取独立的方法配以意图明确的名字。同时跑一下测试用例确保重构的修改对于已有功能无影响。

```cpp
/**
 * @brief Soundex 算法类
 *
 */
class Soundex
{
public:
    /**
     * @brief 按照 Soundex 算法转换输入的字符串内容
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return zeroPad(Word); }

private:
    /**
     * @brief 安装 Soundex 条款4 要求进行补零
     *
     * @param Word
     * @return std::string
     */
    std::string zeroPad(const std::string& Word) const { return Word + "000"; }
};
```

## fixture 与设置

在重构的时候，不仅要审阅产品代码，还要审阅测试。现在测试代码中存在一些重复的地方，每个测试用例的 GIVEN 都需要创建一个 Soundex 对象。有两种方式修改：

- 将两个测试用例合并入一个，公用一个 GIVEN。优点是比较方便修改，缺点如果用例比较多，测试代码会很长。

```cpp
TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A000")); }
        }
        // 第二个 WHEN 执行时会重新从 GIVEN 运行，不受前一个 WHEN 影响
        WHEN("Input one another char")
        {
            auto encoded = soundex.encode("I");
            THEN("Check that the return value pads with zeros") { REQUIRE_THAT(encoded, Equals("I000")); }
        }
    }
}
```

- 第二种便是使用 class fixture 方法，或许 GIVEN 与 WHEN 依旧存在重复，但是个人认为作为单元测试每一个测试阅读起来通顺也是很重要的，并且本文采用的单元测试编写风格就是 BDD-ScenarioGivenWhenThen：

```cpp
class FixtureSoundex
{
public:
    Soundex MSoundex;
};

TEST_CASE_METHOD(FixtureSoundex, "Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A MSoundex member")
    {
        WHEN("Input one char")
        {
            auto encoded = MSoundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A000")); }
        }
    }
}

TEST_CASE_METHOD(FixtureSoundex, "Pads with zeros to ensure three digits", "[SoundexEncoding]")
{
    GIVEN("A MSoundex member")
    {
        WHEN("Input one char")
        {
            auto encoded = MSoundex.encode("I");
            THEN("Check that the return value pads with zeros") { REQUIRE_THAT(encoded, Equals("I000")); }
        }
    }
}
```

Catch2 会在运行每个测试时创建 fixture 实例。现在就可以删除测试内的局部变量 soundex。