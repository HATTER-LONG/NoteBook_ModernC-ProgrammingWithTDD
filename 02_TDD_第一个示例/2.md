# 测试驱动开发：第一个示例

- [测试驱动开发：第一个示例](#测试驱动开发第一个示例)
  - [前言](#前言)
  - [Soundex 类](#soundex-类)
  - [Let's start](#lets-start)
  - [去掉不干净的代码](#去掉不干净的代码)
    - [命名空间的修复](#命名空间的修复)
    - [消除重复代码](#消除重复代码)
  - [增量性](#增量性)
  - [fixture 与设置](#fixture-与设置)
  - [思索与测试驱动开发](#思索与测试驱动开发)

## 前言

写个测试，保证它通过，接着重构设计，这就是 TDD 的全部内容了。

## Soundex 类

以 TDD 的方式开发 Soundex 类，这种类可以提升应用程序的搜索能力。这个算法是将单词编码为一个字母和三个数字，它将发音相似的单词映射到相同的编码。[Wiki 解释](http://en.wikipedia.org/wiki/Soundex)：

1. 保留第一个字母。丢掉所有出现的 a、e、i、o、 u、y、h、w。
2. 以数字来代替辅音（第一个字母除外）：
   - b、f、p、v : 1
   - c、g、j、k、q、s、x、z : 2
   - d、t : 3
   - l : 4
   - m、n : 5
   - r : 6

3. 如果相邻字母编码相同，用一个数字表示它们即可。同样，如果出现两个编码相同的字母，且它们被h或w隔开，也这样处理；但如果被元音隔开，就要编码两次。这条规则同样适用于第一个字母。
4. 当得到一个字母和三个数字时，停止处理。如果需要，补零以对齐。

## Let's start

TDD 并非一次将所有测试全部实现，而是每次只关注一个功能点对应的单元测试，当完成后再考虑下一个需要加入系统的功能。

**从宏观的角度来看，TDD 的践行步骤是：编写一个最基本单元功能的测试代码 --> 测试失败 --> 实现功能代码最低限度的使得测试代码通过测试 --> 测试成功 --> 考虑下一个基本单元功能并编写对应测试 --> ...。**

基于这一思路，以 Soundex 举例：最先需要实现的便是步骤一，保留第一个字母：

```cpp
#include "catch2/catch.hpp"

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var") { Soundex soundex; }
}
```

- 我们创建了一个 Soundex 一个对象，然后到此为止，因为现在已经编译不通过了，需要先解决这个问题：
  - 只在为了使失败测试通过时才编写产品代码。
  - 当测试刚好失败时，停止继续编写。编译失败也是失败。
  - 只编写刚好能让一个失败测试通过的产品代码。

现在编译在已经通知未定义 Soundex 的错误：

```cpp
#include "catch2/catch.hpp"

// TODO : 当前暂时与测试代码同一个文件，当感觉代码放在同一个文件有些麻烦时，再用合适的方式迁出
/**
 * @brief 实现 Soundex 类
 *
 */
class Soundex
{
};

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var") { Soundex soundex; }
}
```

现在继续向前添加功能，设计使 Soundex 对外提供一个 encode(string) 公共成员函数，现在代码使无法编译通过：
  
```cpp
...
TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char") { auto encoded = soundex.encode("A"); }
    }
}
...
```

修复错误，使 Soundex 支持 encode 方法：

```cpp
/**
 * @brief Soundex 算法类
 *
 */
class Soundex
{
public:
    /**
     * @brief 按照 Soundex 算法转换输入的字符串内容
     * 
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& word) const { return ""; }
};
```

现在检验返回值是否符合 Soundex 算法转换后的结果：

```cpp
...
       WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Catch::Equals("A")); }
        }
...
```

现在得到了与前边编译失败不同的结果，断言失败。当然这是必然的，因为 encode 方法并没有什么实现。

```c++
/**
 * @brief Soundex 算法类
 *
 */
class Soundex
{
public:
    /**
     * @brief 按照 Soundex 算法转换输入的字符串内容
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return "A"; }
};
```

现在断言能通过了，不过功能并没有完善，不过这里展示了一个渐进式 TDD 开发的过程。

## 去掉不干净的代码

即使代码很短也可能存在问题，TDD 为开发提供了更好的时机去修复，即每次完成单元测试代码以及功能代码编写后都可以进行快速的增量审阅，避免小问题越积越多。

### 命名空间的修复

单元测试代码中，Equals 使用 Catch 命名空间比较影响阅读连贯性，使用命名空间将断言读起来像一个句子：

```cpp
#include "catch2/catch.hpp"

using namespace Catch;

TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A")); }
        }
    }
}
```

### 消除重复代码

重复代码对于维护成本和风险都会提升。审阅代码是需要着重优化。

在此例中没有太明显的重复，但是 `"A"` 这个硬编码的字符串出现了很多回，可以将 encode 方法中返回的硬编码 "A" 优化掉：

```cpp
/**
 * @brief Soundex 算法类
 *
 */
class Soundex
{
public:
    /**
     * @brief 按照 Soundex 算法转换输入的字符串内容
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return Word; }
};
```

任何时候，一个完整的测试集合声明了系统中期望的行为。这里蕴含着一个潜台词：如果一个行为没有对应的测试来描述，那这个行为要么不存在，要么不是期望的（或者测试本身没有尽到描述行为的职责）。

当历经 TDD 的各个周期时，我们会使用重构来审阅设计，同时修复出现的所有问题。重构的主要关注点是提升表达能力，去除重复代码。就代码的可维护性来说，这两个点最有裨益。

## 增量性

对于前文的硬编码可能心存疑虑，但是我们都很清楚硬编码最多存在一小会，随着对目标描述而编写更多的测试用例，逐渐就会替换掉硬编码。

继续完善 Soundex 功能，对于现在的代码并不符 Soundex 规范，以只传递单个字符为前提，并不符合第四条即如果没有三个数字，需要补零。接下来为这个功能编写新的测试。

```cpp
TEST_CASE("Pads with zeros to ensure three digits", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("I");
            THEN("Check that the return value pads with zeros") { REQUIRE_THAT(encoded, Equals("I000")); }
        }
    }
}
```

失败了：

```shell
/home/caolei/WorkSpace/TDD_Learning/test/Catch2/TestSoundex.cpp:45: FAILED:
  REQUIRE_THAT( encoded, Equals("I000") )
with expansion:
  "I" equals: "I000"

===============================================================================
test cases: 2 | 1 passed | 1 failed
assertions: 2 | 1 passed | 1 failed

```

让测试通过：

```cpp
/**
 * @brief 按照 Soundex 算法转换输入的字符串内容
 *
 * @param word
 * @return std::string
 */
std::string encode(const std::string& Word) const { return Word + "000"; }
```

这时会发现第一条用例失败了，这时因为第一条用例与 Soundex 的规则不符合，修改其断言语句已适配规则：

```cpp
TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A000")); }
        }
    }
}
```

现在有两条相似的测试仅仅数据有些差异，但是没有关系，每个测试描述一种行为。**我们不仅要确保系统按预期工作，还要让每个人知道所有既定的系统行为。**

完整这个功能周期后，考虑重构代码。可以发现 encode 的实现有些让人迷惑，尤其是不清楚条款的人看到这种魔数组合叫人心生厌恶 😢，因此需要对其封装下，提取独立的方法配以意图明确的名字。同时跑一下测试用例确保重构的修改对于已有功能无影响。

```cpp
/**
 * @brief Soundex 算法类
 *
 */
class Soundex
{
public:
    /**
     * @brief 按照 Soundex 算法转换输入的字符串内容
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return zeroPad(Word); }

private:
    /**
     * @brief 按照 Soundex 的规则要求进行补零
     *
     * @param Word
     * @return std::string
     */
    std::string zeroPad(const std::string& Word) const { return Word + "000"; }
};
```

## fixture 与设置

在重构的时候，不仅要审阅产品代码，还要审阅测试。现在测试代码中存在一些重复的地方，每个测试用例的 GIVEN 都需要创建一个 Soundex 对象。有两种方式修改：

- 将两个测试用例合并入一个，公用一个 GIVEN。优点是比较方便修改，缺点如果用例比较多，测试代码会很长。

```cpp
TEST_CASE("Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A soundex var")
    {
        Soundex soundex;

        WHEN("Input one char")
        {
            auto encoded = soundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A000")); }
        }
        // 第二个 WHEN 执行时会重新从 GIVEN 运行，不受前一个 WHEN 影响
        WHEN("Input one another char")
        {
            auto encoded = soundex.encode("I");
            THEN("Check that the return value pads with zeros") { REQUIRE_THAT(encoded, Equals("I000")); }
        }
    }
}
```

- 第二种便是使用 class fixture 方法，或许 GIVEN 与 WHEN 依旧存在重复，但是个人认为作为单元测试每一个测试阅读起来通顺也是很重要的，并且本文采用的单元测试编写风格就是 BDD-ScenarioGivenWhenThen：

```cpp
class FixtureSoundex
{
public:
    Soundex MSoundex;
};

TEST_CASE_METHOD(FixtureSoundex, "Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A MSoundex member")
    {
        WHEN("Input one char")
        {
            auto encoded = MSoundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A000")); }
        }
    }
}

TEST_CASE_METHOD(FixtureSoundex, "Pads with zeros to ensure three digits", "[SoundexEncoding]")
{
    GIVEN("A MSoundex member")
    {
        WHEN("Input one char")
        {
            auto encoded = MSoundex.encode("I");
            THEN("Check that the return value pads with zeros") { REQUIRE_THAT(encoded, Equals("I000")); }
        }
    }
}
```

Catch2 会在运行每个测试时创建 fixture 实例。现在就可以删除测试内的局部变量 soundex。现在 Soundex 代码有些长了，是时候要把 TODO 事项解决一下。

```cpp
//Include/Soundex.h
#pragma once

#include <string>

// TODO: 暂时将实现也都放入同一个文件中比较方便修改，后续合适的时机抽出
/**
 * @brief Soundex 算法类
 *
 */
class Soundex
{
public:
    /**
     * @brief 按照 Soundex 算法转换输入的字符串内容
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return zeroPad(Word); }

private:
    /**
     * @brief 安装 Soundex 条款4 要求进行补零
     *
     * @param Word
     * @return std::string
     */
    std::string zeroPad(const std::string& Word) const { return Word + "000"; }
};

```

测试代码：

```cpp
//test/Catch2/TestSoundex.cpp
#include "Soundex.h"
#include "catch2/catch.hpp"
#include "spdlog/spdlog.h"
using namespace Catch;

class FixtureSoundex
{
public:
    Soundex MSoundex;
};

TEST_CASE_METHOD(FixtureSoundex, "Retain sole letter of one letter world", "[SoundexEncoding]")
{
    GIVEN("A MSoundex member")
    {
        WHEN("Input one char")
        {
            auto encoded = MSoundex.encode("A");
            THEN("Check that the return value is correct") { REQUIRE_THAT(encoded, Equals("A000")); }
        }
    }
}

TEST_CASE_METHOD(FixtureSoundex, "Pads with zeros to ensure three digits", "[SoundexEncoding]")
{
    GIVEN("A MSoundex member")
    {
        WHEN("Input one char")
        {
            auto encoded = MSoundex.encode("I");
            THEN("Check that the return value pads with zeros") { REQUIRE_THAT(encoded, Equals("I000")); }
        }
    }
}
```

## 思索与测试驱动开发

简单地说，TDD的周期就是写一个测试，先确保测试失败，然后编码让测试通过，接着审阅代码和打磨设计（包括测试的设计），最后确保所有测试依然通过。

接下来将要处理规则2：即在第一个字母后，用数字替换辅音。替换规则表中字母 b 对应数字 1，以此编写用例：

```cpp
TEST_CASE_METHOD(FixtureSoundex, "Retains sole letter of one letter word")
{
    GIVEN("A MSoundex member")
    {
        WHEN("Enter a word")
        {
            auto encoded = MSoundex.encode("Ab");
            THEN("Check that the return value Retains sole letter of one letter word") { REQUIRE_THAT(encoded, Equals("A100")); }
        }
    }
}
```

不出所料的失败，接下来便是让测试通过，然后重构功能代码。在寻求解决方案时，我们并不需要找到一个通用的方法，**但是也不要使用已有的处理逻辑**，例如：

```cpp
std::string encode(const std::string& word) const {
    if (word == "Ab") return "A100";
    return zeroPad(word);
}
```

编写了这个特例，但是看起来它就像对 Ab 进行特殊处理成 A1 后的补零输出，但是我们已有 zeroPad 了，虽说特例并非错误，我们也可以用其他的测试用例来修改这个特例，这里仅仅是列举出当我想要功能向前开发时的标准，因为一直添加特例也是可行的不是么😀。

```cpp
/**
 * @brief 按照 Soundex 算法转换输入的字符串内容
 *
 * @param word
 * @return std::string
 */
std::string encode(const std::string& Word) const
{
    auto encoded = Word.substr(0, 1);

    if (Word.length() > 1) { encoded += "1"; }
    return zeroPad(encoded);
}
```

Ops，补零出现了错误：

```shell
/home/caolei/WorkSpace/TDD_Learning/test/Catch2/TestSoundex.cpp:43: FAILED:
  REQUIRE_THAT( encoded, Equals("A100") )
with expansion:
  "A1000" equals: "A100"

===============================================================================
test cases: 3 | 2 passed | 1 failed
assertions: 3 | 2 passed | 1 failed
```

修改 zeroPad 方法以通过测试：

```cpp
/**
 * @brief 安装 Soundex 条款4 要求进行补零
 *
 * @param Word
 * @return std::string
 */
std::string zeroPad(const std::string& Word) const
{
    auto zerosNeeded = 4 - Word.length();
    return Word + std::string(zerosNeeded, '0');
}
```

现在看起来不错，用例也已经通过了。但是对于 encode 方法的实现还是有些不满意，其中充斥了一些编码细节和魔数，对于不熟悉功能的其他人阅读起来是灾难的，不多废话重构它🚀：

```cpp
#pragma once

#include <string>

// TODO: 暂时将实现也都放入同一个文件中比较方便修改，后续合适的实际抽出
/**
 * @brief Soundex 算法类
 *
 */
class Soundex
{
public:
    /**
     * @brief 按照 Soundex 算法转换输入的字符串内容
     *
     * @param word
     * @return std::string
     */
    std::string encode(const std::string& Word) const { return zeroPad(head(Word) + encodedDigits(Word)); }

private:
    /**
     * @brief 获取单词的第一个字母
     *
     * @param Word
     * @return std::string
     */
    std::string head(const std::string& Word) const { return Word.substr(0, 1); }

    /**
     * @brief 获取首字母后其他字符转化的对应数字
     *
     * @param Word
     * @return std::string
     */
    std::string encodedDigits(const std::string& Word) const
    {
        if (Word.length() > 1) return "1";
        return "";
    }
    /**
     * @brief 按照 Soundex 的规则要求进行补零
     *
     * @param Word
     * @return std::string
     */
    std::string zeroPad(const std::string& Word) const
    {
        auto zerosNeeded = 4 - Word.length();
        return Word + std::string(zerosNeeded, '0');
    }
};
```

以声明性的方式组织代码，使其非常易于理解。设计中非常重要的一方面是从实现（怎么做）中分离接口（做什么），这提供了迈向更高层次设计方案的跳板。

>有时也会担心一些实现的细节并不是那么好：。第一，是不是应该用 stringstream，而不是直接将字符串连接起来？第二，为什么不尽可能地用单独的 char？例如，为什么用 return words.substr(0, 1); 而非 return word.front();？第三，用 return std::string(); 不是比 return ""; 更好吗？
>
> 这些替代的代码方案可能更好。但这些都是过早优化（premature optimization）。这个时候，一个好的设计（接口一致且代码可读性高）更重要。一旦以牢靠的设计实现了正确的行为后，再考虑是否优化性能。

先不要考虑对于性能进行优化，还是要优先考虑好的代码设计，例如消除代码中的`魔数`，取而代之一个合理名字的常量。

```cpp
static const size_t MaxCodeLength{4};
......
/**
 * @brief 安装 Soundex 的规则要求进行补零
 *
 * @param Word
 * @return std::string
 */
std::string zeroPad(const std::string& Word) const
{
    auto zerosNeeded = MaxCodeLength - Word.length();
    return Word + std::string(zerosNeeded, '0');
}
```

对于 encodedDigits() 中的硬编码 `1`，需要代码将字母 b 替换成 1，而写后续还要支持对其他字符的数字转换，可以通过一个合理的函数名字替代，最终的代码如下：

```cpp
/**
 * @brief 获取首字母后其他字符转化的对应数字
 *
 * @param Word
 * @return std::string
 */
std::string encodedDigits(const std::string& Word) const
{
    if (Word.length() > 1) return encodedDigit();
    return "";
}

/**
 * @brief 获取一个字符对应的数字
 *
 * @return std::string
 */
std::string encodedDigit() const { return "1"; }
```
