# 测试替身

- [测试替身](#测试替身)
  - [依赖问题](#依赖问题)
  - [测试替身原理](#测试替身原理)
  - [手动打造的测试替身](#手动打造的测试替身)

在前面的章节中了解了 TDD 的基础内容，但是在真实的生产环境中对象必须协同工作，有时依赖合作对象使得 TDD 变得举步维艰，本章将会介绍如何使用测试替身来解决。

## 依赖问题

- Story：位置描述服务
  - 作为一个地图应用开发人员，我需要这样的服务，即它能基于给定的位置（经纬度）返回一行信息来描述离它最近的地方。

构建位置描述服务中一个重要的工作就是去调用一个外部 API，这个 API 能接受一个位置信息，并返回位置数据。书中举例 REST 服务，给定一个 GET URL，它会以 JSON 格式返回位置数据。测试驱动开发位置描述服务会遇到一个难题。至少出于以下几点原因，对 REST 调用的依赖会成为一个问题。

1. 通过一个 HTTP 来调用 REST 服务非常缓慢，这也导致测试的运行速度变慢。
2. REST 服务可能不是一直处于可用状态。
3. REST 服务返回的结果得不到保证。

为什么这些依赖会使得测试变得困难呢？

1. 依赖一个慢速的协作对象会让测试慢得难以忍受。
2. 依赖一个不稳定的服务（要么不可用，要么每次返回不同的结果）会导致测试间断性地失败。

而且如果当前没有发起 HTTP 调用的代码，可能是被人还没有设计实现完成，同时你也没有时间自己去实现一个 HTTP 类怎么办？如果自己就是负责 HTTP 类实现的人怎么办？或许可以先了解下位置描述服务整体设计与使用方法后在考虑 HTTP 工具类的具体实现细节。

## 测试替身原理

在上述提到的问题，可以利用`测试替身`来避免被这类问题阻塞。测试替身起到代替的作用：它代替了实际产品代码中的类。

如上文 HTTP 类带来了困难，可以为其创建测试替身！当客户提交一个GET请求至HTTP对象时，测试替身能够返回预先准备的响应。测试替身应该返回什么是由测试自己决定的。

- 假设需要构建一个服务，有以下几个功能类可以复用（当前还未实现）：
  - CurlHttp，它使用 cURL 发起 HTTP 请求。这个类派生自纯虚基类 Http，这个基类定义两个函数：get() 和 initialize()。客户端代码在调用 get() 前必须先调用 initialize()。
  - Address，一个包含几个字段的结构。
  - AddressExtractor，它借助 JsonCpp 库从一个 JSON 字符串中提取地址 (本文将 Catch2 实现版本从书中的 JsonCpp 切换成 nlohmann/json.hpp)，并填写 Address 结构。

可能的代码流程：

```cpp
CurlHttp http;
http.initialize();
auto jsonResponse = http.get(createGetRequestUrl(latitude, longitude));

AddressExtractor extractor;
auto address = extractor.addressFrom(jsonResponse);

return summaryDescription(address);
```

## 手动打造的测试替身

[配套工程](https://github.com/HATTER-LONG/TDD_Learning)参考代码版本：Git SHA (92c0b746c3b862199597c6a9eb2da93abca8a5aa)；

如果想要使用替身，首先必须使其取代 CurlHttp 类的行为。C++提供了许多不同的方法，其中多态的使用频率最高。我们先来看一下 CurlHttp 类所实现的基类 [Http 接口](https://github.com/HATTER-LONG/TDD_Learning/tree/master/Include/Http.h)。

```cpp
virtual ~Http() { }
virtual void initialize() = 0;
virtual std::string get(const std::string& Url) const = 0;
```

利用多态只需要在派生类中覆写虚函数，并在这个覆写中提供特别的行为来支持测试，然后将基类指针传递给地名描述服务。现在来进行一些[测试](https://github.com/HATTER-LONG/TDD_Learning/tree/master/test/Gmock/PlaceDescriptionServiceTest/PlaceDescriptionServiceTest.cpp)：

```cpp
class APlaceDescriptionService : public Test
{
public:
    static const string ValidLatitude;
    static const string ValidLongitude;
};

TEST_F(APlaceDescriptionService, ReturnsDescriptionForValidLocation)
{
    HttpStub httpStub;
    PlaceDescriptionService service { &httpStub };
    auto description = service.summaryDescription(ValidLatitude, ValidLongitude);
    ASSERT_THAT(description, Eq("Drury Ln, Fountain, CO, US"));
}
```

这里我们所需的替身 HttpStub 还没有实现，在测试代码文件中先定义一个。

```cpp
class HttpStub : public Http
{
    void initialize() override { }
    std::string get(const std::string& Url) const override { return "???"; }
};

TEST_F(APlaceDescriptionService, ReturnsDescriptionForValidLocation)
{
    HttpStub httpStub;
....
}
```

返回问号字符串没有什么作用，可以尝试会返回一个搜索服务真实的 Json 响应，[内容可以尝试向 Nominatim 提交 Get 请求获取](https://nominatim.org/release-docs/develop/api/Search/#parameters)，这里保持书中的示例：

```cpp
class HttpStub : public Http
{
    void initialize() override { }
    std::string get(const std::string& Url) const override
    {
        return R"({ "address": {
         "road":"Drury Ln",
         "city":"Fountain",
         "state":"CO",
         "country":"US" }})";
    }
};
```

接下来将 HttpStub 实例传递给了 PlaceDescriptionService 的构造函数。和原先的预想相比，我们正在改变设计。**服务对象本身不创建私有的 Http 实例，相反，使用该服务对象的客户端需要自己创建一个 Http 实例，并把它传给服务对象**。[服务对象](https://github.com/HATTER-LONG/TDD_Learning/tree/master/Src/PlaceDescriptionService/PlaceDescriptionService.cpp)通过一个基类指针持有这个 Http 实例。

```cpp
PlaceDescriptionService::PlaceDescriptionService(Http* IHttp)
        : MHttp(IHttp)
{
}
```

利用多态实现了灵活的测试替身，功能类 `PlaceDescriptionService` 不清楚它持有的 Http 实例时一个真实的还是一个测试用的实例。

**参考代码版本：Git SHA (05f37b1b63764fdd54fe4d9555b3b9d276136d6d)；**

继续向下 summaryDescription 接口调用的参数是需要传入两个坐标，这里为 ValidLatitude、ValidLongitude 进行初始化：

```cpp
class APlaceDescriptionService : public Test
{
public:
    static const string ValidLatitude;
    static const string ValidLongitude;
};

const string APlaceDescriptionService::ValidLatitude("38.005");
const string APlaceDescriptionService::ValidLongitude("-104.44");
```

这时编译成功可以运行一下哎，不出意外失败了这时由于还没有具体实现 summaryDescription 接口的功能。

至此，可以编写 summaryDescription() 了。但是首先还需要一个 AddressExtractor。它能解析 JSON 响应，并填写 Address 结构体。详细的过程略过，可以查阅[源码](https://github.com/HATTER-LONG/TDD_Learning/tree/master/Src/PlaceDescriptionService/AddressExtractor.cpp)。

```cpp
.....
TEST_F(AnAddressExtractor, ReturnsPopulatedAddressForValidJsonResult)
{
    const auto* json = R"({
         "place_id":"15331615",
         "address":{
            "road":"War Eagle Court",
            "city":"Colorado Springs",
            "state":"Colorado",
            "country":"United States of America",
         }
      })";

    auto address = Extractor.addressFrom(json);

    ASSERT_THAT(address.Road, Eq("War Eagle Court"));
    ASSERT_THAT(address.City, Eq("Colorado Springs"));
    ASSERT_THAT(address.State, Eq("Colorado"));
    ASSERT_THAT(address.Country, Eq("United States of America"));
}
.....
```

最后我们实现 summaryDescription()：

```cpp
string PlaceDescriptionService::summaryDescription(const string& Latitude, const string& Longitude) const
{
    const auto* getRequestUrl = "";
    auto jsonResponse = MHttp->get(getRequestUrl);
    AddressExtractor extractor;
    auto address = extractor.addressFrom(jsonResponse);
    return address.Road + ", " + address.City + ", " + address.State + ", " + address.Country;
}
```

**下边参考代码版本：Git SHA (432dedc2c1589fe7a8bfb3487879fec56997e6fa)；**

当测试调用 summaryDescription() 时，对 get() 的调用作用到 HttpStub 实例上，返回我们预先硬编码的 Json 字符串。但是请求的 URL 应该是什么，当正在接受测试的代码和一个协同对象交互时，需要保证给它传递一个正确的值。返回硬编码值的测试替身叫作存根（stub）。类似地，我们也可以称 get() 为存根方法。

实际上，当传给 get() 一个空的字符串时就可以进行增量的开发了，接下来编写能够正确给 getRequestUrl 赋值的代码。**利用三角法，并为第二个位置添加一个断言**。

```cpp
class HttpStub : public Http
{
    void initialize() override { }
    std::string get(const std::string& Url) const override
    {
        verify(Url);
        return R"({ "address": {
         "road":"Drury Ln",
         "city":"Fountain",
         "state":"CO",
         "country":"US" }})";
    }

    void verify(const string& Url) const
    {
        auto expectedArgs("lat=" + APlaceDescriptionService::ValidLatitude + "&" +
                          "lon=" + APlaceDescriptionService::ValidLongitude);
        ASSERT_THAT(Url, EndsWith(expectedArgs));
    }
};
```

在调用 get() 时，存根实现可以确保参数符合预期，接下来修改代码通过测试：

```cpp
string PlaceDescriptionService::summaryDescription(const string& Latitude, const string& Longitude) const
{
    const string& getRequestUrl = "lat=" + Latitude + "&lon=" + Longitude;
    auto jsonResponse = MHttp->get(getRequestUrl);
    AddressExtractor extractor;
    auto address = extractor.addressFrom(jsonResponse);
    return address.Road + ", " + address.City + ", " + address.State + ", " + address.Country;
}
```

由于当前 URL 没有指定服务器路径，修改 verify() 函数，让它传给 get() 一个完整的 URL:

```cpp
void verify(const string& Url) const
{
    string urlStart("http://open.mapquestapi.com/nominatim/v1/reverse?format=json&");
    auto expectedArgs(urlStart + "lat=" + APlaceDescriptionService::ValidLatitude + "&" +
                        "lon=" + APlaceDescriptionService::ValidLongitude);
    ASSERT_THAT(Url, Eq(expectedArgs));
}
```

最终实现 summaryDescription() 方法后：

```cpp
string PlaceDescriptionService::summaryDescription(const string& Latitude, const string& Longitude) const
{
    auto request = createGetRequestUrl(Latitude, Longitude);
    auto response = get(request);
    return summaryDescription(response);
}
string PlaceDescriptionService::summaryDescription(const string& Response) const
{
    AddressExtractor extractor;
    auto address = extractor.addressFrom(Response);
    return address.summaryDescription();
}
string PlaceDescriptionService::get(const string& RequestUrl) const
{
    return MHttp->get(RequestUrl);
}

string PlaceDescriptionService::createGetRequestUrl(const string& Latitude, const string& Longitude) const
{
    string server { "http://open.mapquestapi.com/" };
    string document { "nominatim/v1/reverse" };
    return server + document + "?" + keyValue("format", "json") + "&" + keyValue("lat", Latitude) + "&" +
           keyValue("lon", Longitude);
}

string PlaceDescriptionService::keyValue(const std::string& Key, const std::string& Value) const
{
    return Key + "=" + Value;
}
```

- 现在代码中还欠缺的地方：
  1. 重复代码：测试中的文本和产品代码中的文本完全一样。第七章会讲解如何去除这种重复。
  2. PlaceDescriptionService 中的一些结构是可以复用的。可以考虑如何设计更加方便支持第二个服务。
