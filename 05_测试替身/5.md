# 测试替身

- [测试替身](#测试替身)
  - [依赖问题](#依赖问题)
  - [测试替身原理](#测试替身原理)
  - [手动打造的测试替身](#手动打造的测试替身)
  - [在使用测试替身时提升测试的抽象程度](#在使用测试替身时提升测试的抽象程度)

在前面的章节中了解了 TDD 的基础内容，但是在真实的生产环境中对象必须协同工作，有时依赖合作对象使得 TDD 变得举步维艰，本章将会介绍如何使用测试替身来解决。

## 依赖问题

- Story：位置描述服务
  - 作为一个地图应用开发人员，我需要这样的服务，即它能基于给定的位置（经纬度）返回一行信息来描述离它最近的地方。

构建位置描述服务中一个重要的工作就是去调用一个外部 API，这个 API 能接受一个位置信息，并返回位置数据。书中举例 REST 服务，给定一个 GET URL，它会以 JSON 格式返回位置数据。测试驱动开发位置描述服务会遇到一个难题。至少出于以下几点原因，对 REST 调用的依赖会成为一个问题。

1. 通过一个 HTTP 来调用 REST 服务非常缓慢，这也导致测试的运行速度变慢。
2. REST 服务可能不是一直处于可用状态。
3. REST 服务返回的结果得不到保证。

为什么这些依赖会使得测试变得困难呢？

1. 依赖一个慢速的协作对象会让测试慢得难以忍受。
2. 依赖一个不稳定的服务（要么不可用，要么每次返回不同的结果）会导致测试间断性地失败。

而且如果当前没有发起 HTTP 调用的代码，可能是被人还没有设计实现完成，同时你也没有时间自己去实现一个 HTTP 类怎么办？如果自己就是负责 HTTP 类实现的人怎么办？或许可以先了解下位置描述服务整体设计与使用方法后在考虑 HTTP 工具类的具体实现细节。

## 测试替身原理

在上述提到的问题，可以利用`测试替身`来避免被这类问题阻塞。测试替身起到代替的作用：它代替了实际产品代码中的类。

如上文 HTTP 类带来了困难，可以为其创建测试替身！当客户提交一个GET请求至HTTP对象时，测试替身能够返回预先准备的响应。测试替身应该返回什么是由测试自己决定的。

- 假设需要构建一个服务，有以下几个功能类可以复用（当前还未实现）：
  - CurlHttp，它使用 cURL 发起 HTTP 请求。这个类派生自纯虚基类 Http，这个基类定义两个函数：get() 和 initialize()。客户端代码在调用 get() 前必须先调用 initialize()。
  - Address，一个包含几个字段的结构。
  - AddressExtractor，它借助 JsonCpp 库从一个 JSON 字符串中提取地址 (本文将 Catch2 实现版本从书中的 JsonCpp 切换成 nlohmann/json.hpp)，并填写 Address 结构。

可能的代码流程：

```cpp
CurlHttp http;
http.initialize();
auto jsonResponse = http.get(createGetRequestUrl(latitude, longitude));

AddressExtractor extractor;
auto address = extractor.addressFrom(jsonResponse);

return summaryDescription(address);
```

## 手动打造的测试替身

[配套工程](https://github.com/HATTER-LONG/TDD_Learning)参考代码版本：Git SHA (92c0b746c3b862199597c6a9eb2da93abca8a5aa)；

如果想要使用替身，首先必须使其取代 CurlHttp 类的行为。C++提供了许多不同的方法，其中多态的使用频率最高。我们先来看一下 CurlHttp 类所实现的基类 [Http 接口](https://github.com/HATTER-LONG/TDD_Learning/tree/master/Include/Http.h)。

```cpp
virtual ~Http() { }
virtual void initialize() = 0;
virtual std::string get(const std::string& Url) const = 0;
```

利用多态只需要在派生类中覆写虚函数，并在这个覆写中提供特别的行为来支持测试，然后将基类指针传递给地名描述服务。现在来进行一些[测试](https://github.com/HATTER-LONG/TDD_Learning/tree/master/test/Gmock/PlaceDescriptionServiceTest/PlaceDescriptionServiceTest.cpp)：

```cpp
class APlaceDescriptionService : public Test
{
public:
    static const string ValidLatitude;
    static const string ValidLongitude;
};

TEST_F(APlaceDescriptionService, ReturnsDescriptionForValidLocation)
{
    HttpStub httpStub;
    PlaceDescriptionService service { &httpStub };
    auto description = service.summaryDescription(ValidLatitude, ValidLongitude);
    ASSERT_THAT(description, Eq("Drury Ln, Fountain, CO, US"));
}
```

这里我们所需的替身 HttpStub 还没有实现，在测试代码文件中先定义一个。

```cpp
class HttpStub : public Http
{
    void initialize() override { }
    std::string get(const std::string& Url) const override { return "???"; }
};

TEST_F(APlaceDescriptionService, ReturnsDescriptionForValidLocation)
{
    HttpStub httpStub;
....
}
```

返回问号字符串没有什么作用，可以尝试会返回一个搜索服务真实的 Json 响应，[内容可以尝试向 Nominatim 提交 Get 请求获取](https://nominatim.org/release-docs/develop/api/Search/#parameters)，这里保持书中的示例：

```cpp
class HttpStub : public Http
{
    void initialize() override { }
    std::string get(const std::string& Url) const override
    {
        return R"({ "address": {
         "road":"Drury Ln",
         "city":"Fountain",
         "state":"CO",
         "country":"US" }})";
    }
};
```

接下来将 HttpStub 实例传递给了 PlaceDescriptionService 的构造函数。和原先的预想相比，我们正在改变设计。**服务对象本身不创建私有的 Http 实例，相反，使用该服务对象的客户端需要自己创建一个 Http 实例，并把它传给服务对象**。[服务对象](https://github.com/HATTER-LONG/TDD_Learning/tree/master/Src/PlaceDescriptionService/PlaceDescriptionService.cpp)通过一个基类指针持有这个 Http 实例。

```cpp
PlaceDescriptionService::PlaceDescriptionService(Http* IHttp)
        : MHttp(IHttp)
{
}
```

利用多态实现了灵活的测试替身，功能类 `PlaceDescriptionService` 不清楚它持有的 Http 实例时一个真实的还是一个测试用的实例。

**参考代码版本：Git SHA (05f37b1b63764fdd54fe4d9555b3b9d276136d6d)；**

继续向下 summaryDescription 接口调用的参数是需要传入两个坐标，这里为 ValidLatitude、ValidLongitude 进行初始化：

```cpp
class APlaceDescriptionService : public Test
{
public:
    static const string ValidLatitude;
    static const string ValidLongitude;
};

const string APlaceDescriptionService::ValidLatitude("38.005");
const string APlaceDescriptionService::ValidLongitude("-104.44");
```

这时编译成功可以运行一下哎，不出意外失败了这时由于还没有具体实现 summaryDescription 接口的功能。

至此，可以编写 summaryDescription() 了。但是首先还需要一个 AddressExtractor。它能解析 JSON 响应，并填写 Address 结构体。详细的过程略过，可以查阅[源码](https://github.com/HATTER-LONG/TDD_Learning/tree/master/Src/PlaceDescriptionService/AddressExtractor.cpp)。

```cpp
.....
TEST_F(AnAddressExtractor, ReturnsPopulatedAddressForValidJsonResult)
{
    const auto* json = R"({
         "place_id":"15331615",
         "address":{
            "road":"War Eagle Court",
            "city":"Colorado Springs",
            "state":"Colorado",
            "country":"United States of America",
         }
      })";

    auto address = Extractor.addressFrom(json);

    ASSERT_THAT(address.Road, Eq("War Eagle Court"));
    ASSERT_THAT(address.City, Eq("Colorado Springs"));
    ASSERT_THAT(address.State, Eq("Colorado"));
    ASSERT_THAT(address.Country, Eq("United States of America"));
}
.....
```

最后我们实现 summaryDescription()：

```cpp
string PlaceDescriptionService::summaryDescription(const string& Latitude, const string& Longitude) const
{
    const auto* getRequestUrl = "";
    auto jsonResponse = MHttp->get(getRequestUrl);
    AddressExtractor extractor;
    auto address = extractor.addressFrom(jsonResponse);
    return address.Road + ", " + address.City + ", " + address.State + ", " + address.Country;
}
```

**下边参考代码版本：Git SHA (432dedc2c1589fe7a8bfb3487879fec56997e6fa)；**

当测试调用 summaryDescription() 时，对 get() 的调用作用到 HttpStub 实例上，返回我们预先硬编码的 Json 字符串。但是请求的 URL 应该是什么，当正在接受测试的代码和一个协同对象交互时，需要保证给它传递一个正确的值。返回硬编码值的测试替身叫作存根（stub）。类似地，我们也可以称 get() 为存根方法。

实际上，当传给 get() 一个空的字符串时就可以进行增量的开发了，接下来编写能够正确给 getRequestUrl 赋值的代码。**利用三角法，并为第二个位置添加一个断言**。

```cpp
class HttpStub : public Http
{
    void initialize() override { }
    std::string get(const std::string& Url) const override
    {
        verify(Url);
        return R"({ "address": {
         "road":"Drury Ln",
         "city":"Fountain",
         "state":"CO",
         "country":"US" }})";
    }

    void verify(const string& Url) const
    {
        auto expectedArgs("lat=" + APlaceDescriptionService::ValidLatitude + "&" +
                          "lon=" + APlaceDescriptionService::ValidLongitude);
        ASSERT_THAT(Url, EndsWith(expectedArgs));
    }
};
```

在调用 get() 时，存根实现可以确保参数符合预期，接下来修改代码通过测试：

```cpp
string PlaceDescriptionService::summaryDescription(const string& Latitude, const string& Longitude) const
{
    const string& getRequestUrl = "lat=" + Latitude + "&lon=" + Longitude;
    auto jsonResponse = MHttp->get(getRequestUrl);
    AddressExtractor extractor;
    auto address = extractor.addressFrom(jsonResponse);
    return address.Road + ", " + address.City + ", " + address.State + ", " + address.Country;
}
```

由于当前 URL 没有指定服务器路径，修改 verify() 函数，让它传给 get() 一个完整的 URL:

```cpp
void verify(const string& Url) const
{
    string urlStart("http://open.mapquestapi.com/nominatim/v1/reverse?format=json&");
    auto expectedArgs(urlStart + "lat=" + APlaceDescriptionService::ValidLatitude + "&" +
                        "lon=" + APlaceDescriptionService::ValidLongitude);
    ASSERT_THAT(Url, Eq(expectedArgs));
}
```

最终实现 summaryDescription() 方法后：

```cpp
string PlaceDescriptionService::summaryDescription(const string& Latitude, const string& Longitude) const
{
    auto request = createGetRequestUrl(Latitude, Longitude);
    auto response = get(request);
    return summaryDescription(response);
}
string PlaceDescriptionService::summaryDescription(const string& Response) const
{
    AddressExtractor extractor;
    auto address = extractor.addressFrom(Response);
    return address.summaryDescription();
}
string PlaceDescriptionService::get(const string& RequestUrl) const
{
    return MHttp->get(RequestUrl);
}

string PlaceDescriptionService::createGetRequestUrl(const string& Latitude, const string& Longitude) const
{
    string server { "http://open.mapquestapi.com/" };
    string document { "nominatim/v1/reverse" };
    return server + document + "?" + keyValue("format", "json") + "&" + keyValue("lat", Latitude) + "&" +
           keyValue("lon", Longitude);
}

string PlaceDescriptionService::keyValue(const std::string& Key, const std::string& Value) const
{
    return Key + "=" + Value;
}
```

- 现在代码中还欠缺的地方：
  1. 重复代码：测试中的文本和产品代码中的文本完全一样。第七章会讲解如何去除这种重复。
  2. PlaceDescriptionService 中的一些结构是可以复用的。可以考虑如何设计更加方便支持第二个服务。

## 在使用测试替身时提升测试的抽象程度

**参考代码版本：Git SHA (71f934b009b744e4fd3d66d1a8d21792ad88471a)；**

在使用测试替身时，由于测试中模糊的信息增加了许多理解的难度，例如 ReturnsDescriptionForValidLocation 测试中隐藏了许多相关信息，为什么最终断言的比对目标是 Drury Ln, Fountain, CO, US 这些都会给阅读测试的人查看 HttpStub 中与之相关的实现细节才能理解。

因此我们需要重构测试，使它可以自包含。可以修改 HttpStub 的实现，让测试负责设定 get() 方法的返回值。

```cpp
class HttpStub : public Http
{
public:
    string ReturnResponse;
    void initialize() override { }
    std::string get(const std::string& Url) const override
    {
        verify(Url);
        return ReturnResponse;
    }

    void verify(const string& Url) const
    {
        .....
    }
};

TEST_F(APlaceDescriptionService, ReturnsDescriptionForValidLocation)
{
    HttpStub httpStub;
    httpStub.ReturnResponse = R"({"address": {
                                    "road":"Drury Ln",
                                    "city":"Fountain",
                                    "state":"CO",
                                    "country":"US" }})";
    PlaceDescriptionService service { &httpStub };
    auto description = service.summaryDescription(ValidLatitude, ValidLongitude);
    ASSERT_THAT(description, Eq("Drury Ln, Fountain, CO, US"));
}
```

这样阅读的人可以将摘要描述和 HttpStub 返回的 JSON 对象对应起来，类似的，也可以将URL验证以到测试中。

```cpp
class HttpStub : public Http
{
public:
    string ReturnResponse;
    string ExpectedURL;
    void initialize() override { }
    std::string get(const std::string& Url) const override
    {
        verify(Url);
        return ReturnResponse;
    }

    void verify(const string& Url) const { ASSERT_THAT(Url, Eq(ExpectedURL)); }
};

TEST_F(APlaceDescriptionService, ReturnsDescriptionForValidLocation)
{
    HttpStub httpStub;
    httpStub.ReturnResponse = //....

    string urlStart { "http://open.mapquestapi.com/nominatim/v1/reverse?format=json&" };
    httpStub.ExpectedURL = urlStart + "lat=" + APlaceDescriptionService::ValidLatitude + "&" +
                           "lon=" + APlaceDescriptionService::ValidLongitude;

    PlaceDescriptionService service { &httpStub };
    //.....
}
```

现在，在测试代码中可以清晰的表达出意图，同时 HttpStub 消减至一个小类，返回需要的存根同时验证期望的信息。，一个 HttpStub 对象验证了这样的事实：会有一个期望的 URL 传给 HttpStub。

## 使用模拟对象工具

本结学习如何使用 Google Mock 来实现对多个相似的模拟对象辅助生成 Mock 对象的方法。

### 定义一个派生类

**参考代码版本：Git SHA (74290eccd1b383da76082716ac070f7b06609a28)；**

现在已重新开发 summaryDescription() 举例，我们需要模拟 HTTP 的方法：get() 和 initialize()。

为了使用 Google Mock 自身的模拟对象，我们首先需要创建一个派生类用来声明所模拟的方法。Google Mock 允许我们简洁地定义名为 HttpStub 的派生类。

```cpp
class HttpStub : public Http
{
public:
    MOCK_METHOD0(initialize, void()); // 使用宏来声明模拟的方法
    MOCK_CONST_METHOD1(get, string(const string&)); // 1 标识一个参数，第一个参数成员函数名称，第二个宏参数给出方法其他信息(返回值和参数声明)
};
```

GoogleTest 1.10.x Release 版本支持了一个新宏定义，舍去了繁琐的方法，使用如下：

```cpp
class HttpStub : public Http
{
public:
    MOCK_METHOD(void, initialize, (), (override));
    MOCK_METHOD(string, get, (const string&), (const override));
};
CmakeLists.txt
//当前使用的 googletest 版本为 1.10.x MOCK_METHOD 宏在编译器下会有错误信息，依据 gmock issues 无用报错 关闭相关警告
add_definitions(-Wno-gnu-zero-variadic-macro-arguments)
```

Google Mock 把一个 mock 声明转为派生类中的一个成员函数。Google Mock还在幕后实现了这个函数。

### 设立期望

**参考代码版本：Git SHA (8e49b0b7091856f6308584b40d1d8bdc2114c621)；**

首先屏蔽掉 summaryDescription() 的具体实现重新开发一次。

```cpp
TEST_F(APlaceDescriptionService, ReturnsDescriptionForValidLocation)
{
    HttpStub httpStub;
    string urlStart { "http://open.mapquestapi.com/nominatim/v1/reverse?format=json&" };
    auto expectedURL = urlStart + "lat=" + APlaceDescriptionService::ValidLatitude + "&" +
                       "lon=" + APlaceDescriptionService::ValidLongitude;

    EXPECT_CALL(httpStub, get(expectedURL));
    PlaceDescriptionService service { &httpStub };
    service.summaryDescription(ValidLatitude, ValidLongitude);
}
```

通过 EXPECT_CALL 宏设立期望，这个宏配置 Google Mock 去验证给定的 expectedURL 参数去调用 httpStub 对象的 get() 逻辑是否吻合。其断言生效在模拟对象跳出作用域后开始验证，断言步骤被隐式的执行了。

如果需要，也可以强制 Google Mock 在模拟对象跳出作用域前做验证: `Mock::VerifyAndClearExpectations(&httpStub);`

首先空实现 summaryDescription()，让测试可以编译运行：

```cpp
string PlaceDescriptionService::summaryDescription(const string& Latitude, const string& Longitude) const
{
    return "";
}

```

执行后，测试出现失败信息，直到测试结束为止，httpStub 对象的 get() 也没有被调用。：

```shell
[----------] 1 test from APlaceDescriptionService
[ RUN      ] APlaceDescriptionService.ReturnsDescriptionForValidLocation
/home/caolei/WorkSpace/TDD_Learning/test/Gmock/PlaceDescriptionServiceTestByGMock/PlaceDescriptionServiceTest.cpp:36: Failure
Actual function call count doesn't match EXPECT_CALL(httpStub, get(expectedURL))...
         Expected: to be called once
           Actual: never called - unsatisfied and active
[  FAILED  ] APlaceDescriptionService.ReturnsDescriptionForValidLocation (0 ms)
[----------] 1 test from APlaceDescriptionService (0 ms total)
```

修改代码使之通过测试：

```cpp
string PlaceDescriptionService::summaryDescription(const string& Latitude, const string& Longitude) const
{
    string server { "http://open.mapquestapi.com/" };
    string document { "nominatim/v1/reverse" };
    // clang-format off
    string url = server + document + "?" + 
                    keyValue("format", "json") + "&" + 
                    keyValue("lat", Latitude) + "&" + 
                    keyValue("lon", Longitude);
    // clang-format on
    auto response = MHttp->get(url);
    AddressExtractor extractor;
    auto address = extractor.addressFrom(response);
    return address.summaryDescription();
}
```

### 松模拟和严模拟

**参考代码版本：Git SHA (46639a97cb73d0cd34071e70e1cc0bd05560fc94)；**

summaryDescription() 的视线中并没有遵顼 CurlHttp 接口规则，即在使用 get() 前没有进行 initialize 初始化。可以在测试中新增一个期望来确保初始化被调用：

```cpp
TEST_F(APlaceDescriptionService, ReturnsDescriptionForValidLocation)
{
    HttpStub httpStub;
    string urlStart { "http://open.mapquestapi.com/nominatim/v1/reverse?format=json&" };
    auto expectedURL = urlStart + "lat=" + APlaceDescriptionService::ValidLatitude + "&" +
                       "lon=" + APlaceDescriptionService::ValidLongitude;

    EXPECT_CALL(httpStub, initialize());
    EXPECT_CALL(httpStub, get(expectedURL));
    PlaceDescriptionService service { &httpStub };
    service.summaryDescription(ValidLatitude, ValidLongitude);
}
```

接下来保持 summaryDescription() 中策略不变，单独抽离 get() 接口成为单独的方法：

```cpp
string PlaceDescriptionService::get(const string& Url) const
{
    MHttp->initialize();
    return MHttp->get(Url);
}
```

### 模拟对象中的顺序

**参考代码版本：Git SHA (e1a51df6b0e5af65d328017b1e9c9ebb1b46b0ea)；**

initialize() 和 get() 的调用是有先后顺序的，默认情况下 GMOCK 不会验证满足调用期望的顺序，如果想要验证，可以定义 InSequence 实例：

```cpp
TEST_F(APlaceDescriptionService, ReturnsDescriptionForValidLocation)
{
    InSequence forceExpectationOrder;

    HttpStub httpStub;
    string urlStart { "http://open.mapquestapi.com/nominatim/v1/reverse?format=json&" };
    auto expectedURL = urlStart + "lat=" + APlaceDescriptionService::ValidLatitude + "&" +
                       "lon=" + APlaceDescriptionService::ValidLongitude;

    EXPECT_CALL(httpStub, initialize());
    EXPECT_CALL(httpStub, get(expectedURL));
    PlaceDescriptionService service { &httpStub };
    service.summaryDescription(ValidLatitude, ValidLongitude);
}
```

还可以更加精细控制，具体使用可以参见 [GoogleMock DOC](https://github.com/google/googletest/blob/master/docs/gmock_cheat_sheet.md)：

```cpp
TEST_F(APlaceDescriptionService, ReturnsDescriptionForValidLocation)
{
    HttpStub httpStub;
    string urlStart { "http://open.mapquestapi.com/nominatim/v1/reverse?format=json&" };
    auto expectedURL = urlStart + "lat=" + APlaceDescriptionService::ValidLatitude + "&" +
                       "lon=" + APlaceDescriptionService::ValidLongitude;

    Expectation Expectations = EXPECT_CALL(httpStub, initialize());
    EXPECT_CALL(httpStub, get(expectedURL)).After(Expectations);

    PlaceDescriptionService service { &httpStub };
    service.summaryDescription(ValidLatitude, ValidLongitude);
}
```
