# 总结

- [总结](#总结)
  - [依赖问题](#依赖问题)
  - [使用模拟对象工具](#使用模拟对象工具)
    - [设立期望](#设立期望)
  - [排除模拟失败的方法](#排除模拟失败的方法)
  - [使用测试替身](#使用测试替身)
  - [内聚与耦合](#内聚与耦合)
    - [转嫁私有依赖](#转嫁私有依赖)
  - [使用 mock 的策略](#使用-mock-的策略)
    - [明智地使用测试替身](#明智地使用测试替身)
  - [其他关于测试替身的主题](#其他关于测试替身的主题)

真实的生产环境中对象必须协同工作，有时依赖合作对象使得 TDD 变得举步维艰，可以使用 MOCK 技术来解决这些问题。由于 Catch2 没有提供 MOCK 功能支持，本章节主要的代码演示均使用 GMOCK。但是 Catch2 也是可以利用 GMOCK 相关宏来完善测试需要，[具体使用](https://github.com/HATTER-LONG/TDD_Learning/tree/master/test/Catch2/PlaceDescriptionServiceTestByGMock)。

## 依赖问题

当构建产品代码是无法避免与第三方进行交互，这时就会有许多不确定性（接口不稳定、速度慢、甚至没有开发完成等等），这时就可以利用 MOCK 替身技术来避免阻塞。

## 使用模拟对象工具

```cpp
class HttpStub : public Http
{
public:
    MOCK_METHOD(void, initialize, (), (override));
    MOCK_METHOD(string, get, (const string&), (const override));
};
//CmakeLists.txt
//当前使用的 googletest 版本为 1.10.x MOCK_METHOD 宏在编译器下会有错误信息，依据 gmock issues 无用报错 关闭相关警告
add_definitions(-Wno-gnu-zero-variadic-macro-arguments)
```

### 设立期望

通过 EXPECT_CALL 宏设立期望，这个宏配置 Google Mock 去验证以给定的参数去调用目标对象逻辑是否吻合，[详见例程](./5.md#设立期望)。

EXPECT_CALL 宏支持许多修饰符。它的语法如下（?和*代表每个修饰符的基数：?表示可以选用修饰符一次；*表示可以多次使用修饰符。）：

```cpp
EXPECT_CALL(mock-object, method (matchers)?)
     .With(multi-argument-matcher)  ?
     .Times(cardinality)            ?
     .InSequence(sequences)         *
     .After(expectations)           *
     .WillOnce(action)              *
     .WillRepeatedly(action)        ?
     .RetiresOnSaturation();        ?
```

## 排除模拟失败的方法

1. 产品代码中是否有合理调用？
2. 是否正确定义了模拟方法？
3. 有没有将要模拟的成员函数声明为虚函数？
4. MOCK_METHOD() 声明正不正确？
5. 排除参数匹配的担忧，为所有参数和返回值使用通配符 testing::_ ，如果测试通过，那么可以确定有一个参数不能被正确匹配。

## 使用测试替身

在引入一个测试替身时需要做两件事。第一，编写测试替身。第二，在目标测试中使用测试替身的一个实例。这样的做法又称作依赖注入（Dependency Injection，DI）。

1. [覆写工厂方法和覆写 Getter](./5.md#覆写工厂方法和覆写-getter)
2. [使用工厂](./5.md#使用工厂)
3. [通过模板参数](./5.md#通过模板参数)
4. [注入工具](./5.md#注入工具)

## 内聚与耦合

在典型的后测试代码情况，开发者可能不会经常进行重构，通常他们也无法使用快速的测试让重构变得更快更安全。这样往往产生一些冗余且耦合的代码。即使这样也可以对其进行测试，能够利用到的技术：

- link substitution 写一个快速的单元测试（参见8.9节）。
- 通过整体行为验证的集成测试。

### 转嫁私有依赖

注入模式往往需要对客户端调用产生依赖关系，即 setter 或者构造注入。

Q: setter 或构造函数注入是不是违反了信息隐藏？
A: 从客户端程序的角度来说，确实是违反了。但是有几种方法有效避免：

1. 使用其他依赖注入方法，使得某人即使利用了这些暴露出的信息，也无法造成不好的影响。
2. 提供某人的实例，先配置一个默认的实例，如果测试提供了 HttpStub 实例，那么它将被替换。而真正的客户端时不需要做什么改动的。

Q: 如果心怀恶意的开发者提供一个具有破坏性的 Http 实例呢？
A: 如果产品的客户是团队之外的人，那么可以选择其他注入形式。如果担心团队内部的开发者有意利用注入点做些不好的事，那你将面临更大的问题。

Q: 我逐渐能够测试驱动开发了，但我担心仅仅为了测试的目的而改变我的设计方法。我的团队中的其他人可能也会这么觉得。
A: 确切地了解软件能如期工作是改变设计方式的重要原因。你可以这样和同事讲：“我更关心代码是否如期工作。做出这么一个小的让步意味着我们能够更容易地测试代码，也会有更多的测试能够帮助我们更容易地打磨设计，我们也会对代码更有信心。所以你们能重新思考下我们的标准吗？”

## 使用 mock 的策略

在开发前期，可以通过引入 mock 来替代缺失的协作者功能。**在某一时刻，你或其他人将会实现这个协作者。这时你可以作出以下选择：移除mock，以便待测试的代码使用产品级的协作者；保留mock。**

**如果协作者引入麻烦的依赖，那么就需要保留mock。否则，移除mock会降低测试的复杂度。但是，你也许选择保留它，特别是需要用它来描述与协作者的交互式设计中的重要方面。**

### 明智地使用测试替身

当需要从头 TDD 开发一个带有快速测试的系统，大部分系统功能都需要使用测试替身，在使用时可以参考[这些建议](./5.md#明智地使用测试替身)。

## [其他关于测试替身的主题](./5.md#其他关于测试替身的主题)
