# 增量设计

- [增量设计](#增量设计)
  - [简单设计](#简单设计)
    - [重复代码的代价](#重复代码的代价)
    - [投资管理器](#投资管理器)
    - [投资管理器中的简单重复](#投资管理器中的简单重复)
    - [如何坚持增量的方法](#如何坚持增量的方法)

使用 TDD 的主要原因是，能够以可承受的、稳定的维护成本来添加或修改功能特性。在本章中，你将学到重构过程中需要做的事情。我们将主要讨论 Kent Beck 提出的简单设计理念（参见《解析极限编程：拥抱变化》），以及可以保持代码整洁的一系列重要规则。

## 简单设计

- 在使用 TDD 时需要考虑三条规则：
  1. 确保代码具备很强的可读性和表达力。
  2. 在和第一条规则不冲突的情况下，消除所有的重复。
  3. 不要向系统引入不必要的复杂性。避免猜测行的结构关系和不能增加系统表达力的抽象。

### 重复代码的代价

随着时间的推移，重复代码或许是维护代码库的最大开销。大多数开发者懒于创建新的成员函数，因为怀疑这会降低性能，所以他们有时甚至会拒绝这样做。最终，他们只是为自己创造了更多的未来工作量。

由于对重复的自然倾向，大部分大型系统的代码远远多于实际需要的代码。这些额外的代码大大地增加了维护成本和风险。

**将增量重构作为 TDD 环节的一部分可以避免系统级的退化。**

### 投资管理器

以开发一个小型子系统举例:

- 场景：投资管理器
  - 投资人想要跟踪股票买卖记录，并将此作为金融分析的基础。

本篇示例代码大部分编写过程不在详细赘述，如果需要可以在[源码工程](https://github.com/HATTER-LONG/TDD_Learning)中查找到。

经过初步编写，获得了如下的测试代码：

```cpp
// test/Catch2/PortfolioTest/PortfolioTest.cpp
#include "Portfolio/Portfolio.h"
#include "catch2/catch.hpp"
using namespace Catch;

TEST_CASE("Create portfolio example")
{
    Portfolio portfolio;
}

class APortfolio
{
public:
    Portfolio m_portfolio;
};

TEST_CASE_METHOD(APortfolio, "Is empty whe created", "[Portfolio]")
{
    REQUIRE(m_portfolio.isEmpty());
}

TEST_CASE_METHOD(APortfolio, "Is not empty after purchase", "[Portfolio]")
{
    m_portfolio.purchase("IBM", 1);
    REQUIRE_FALSE(m_portfolio.isEmpty());
}

TEST_CASE_METHOD(APortfolio, "Answers zero for share count of no purchased symbol", "[Portfolio]")
{
    REQUIRE(m_portfolio.shareCount("AAPL") == 0u);
}

TEST_CASE_METHOD(APortfolio, "Answers share count for purchased symbol", "[Portfolio]")
{
    m_portfolio.purchase("IBM", 2);
    REQUIRE(m_portfolio.shareCount("IBM") == 2u);
}
```

```cpp
//Src/Portfolio/Portfolio.h
#pragma once

#include <string>

class Portfolio
{
public:
    Portfolio();
    bool isEmpty() const;
    void purchase(const std::string& Symbol, unsigned int ShareCount);
    unsigned int shareCount(const std::string& Symbol) const;

private:
    bool m_isEmpty;
    unsigned int m_shareCount;
};

//Src/Portfolio/Portfolio.cpp
#include "Portfolio.h"
using namespace std;
Portfolio::Portfolio()
        : m_isEmpty { true }
        , m_shareCount { 0u }
{
}
bool Portfolio::isEmpty() const
{
    return m_isEmpty;
}

void Portfolio::purchase(const string& Symbol, unsigned int ShareCount)
{
    m_isEmpty = false;
    m_shareCount = ShareCount;
}

unsigned int Portfolio::shareCount(const string& Symbol) const
{
    return m_shareCount;
}

```

测试代码就是阅读代码首要的理解途径。

### 投资管理器中的简单重复

**参考代码版本：Git SHA (18fdb0404fcec58c117f776cadb40d4909c50243)；**

首先要知道一点，**不仅仅是生产代码，测试代码中避免重复也是很重要的**。例如字符串 "IBM" 在两个测试中就重复了 3 次。

```cpp
class APortfolio
{
public:
    static const string IBM;
    Portfolio m_portfolio;
};

const string APortfolio::IBM("IBM");
```

使用 IBM 成员替换掉 "IBM" 字符串。

如下代码中也存在重复：

```cpp
#include "Portfolio.h"
using namespace std;
Portfolio::Portfolio()
        : m_isEmpty { true }
        , m_shareCount { 0u }
{
}
bool Portfolio::isEmpty() const
{
    return m_isEmpty;
}

void Portfolio::purchase(const string& Symbol, unsigned int ShareCount)
{
    m_isEmpty = false;
    m_shareCount = ShareCount;
}

unsigned int Portfolio::shareCount(const string& Symbol) const
{
    return m_shareCount;
}
```

从视觉角度来看，代码并没有明显的行与行（或表达式与表达式）的重复。但其中存在算法级的重复。成员函数 IsEmpty() 返回一个布尔量，这个布尔量会在 Purchase() 被调用时更改。但是，空的概念却直接绑定了股票数目，股票数目会在调用 Purchase() 时被赋值。通过去除 m_isEmpty 变量，让 IsEmpty() 查询股票的数量，我们可以消除这一概念重复。

```cpp
#include "Portfolio.h"
using namespace std;
Portfolio::Portfolio()
        : m_shareCount { 0u }
{
}
bool Portfolio::isEmpty() const
{
    return 0 == m_shareCount;
}

void Portfolio::purchase(const string& Symbol, unsigned int ShareCount)
{
    m_shareCount = ShareCount;
}

unsigned int Portfolio::shareCount(const string& Symbol) const
{
    return m_shareCount;
}

```

通过查询股票数量来决定是不是空有些啰嗦，但是目前是正确的。而且随证增量编写代码，往往会有一些更有趣的想发进而促进新测试的产生。例如，有人购买了 0 股某股票，Portfolio::isEmpty() 会返回空。但是我们对于空的定义是是否包含任何股票，所以这是否为空？或者不应该允许这笔买入？确定好前进的方向，并增加一个测试吧。

**算法的重复（解决同一问题的不同方法或问题的不同部分）会随系统增长演变为重大问题。通常来说，随着对一个实现的改动未能编写进其他实现，重复代码会演化为不经意的变体。**

### 如何坚持增量的方法

**参考代码版本：Git SHA (76f547915f27e85a2078d92c70eac8144da2e336)；**

经过一段时间的编码后，我们得到了如下的一些测试：

```cpp
TEST_CASE_METHOD(APortfolio, "Is empty whe created", "[Portfolio]")
TEST_CASE_METHOD(APortfolio, "Is not empty after purchase", "[Portfolio]")
TEST_CASE_METHOD(APortfolio, "Answers zero for share count of no purchased symbol", "[Portfolio]")
TEST_CASE_METHOD(APortfolio, "Answers share count for purchased symbol", "[Portfolio]")
TEST_CASE_METHOD(APortfolio, "Throw on purchase of zero shares", "[Portfolio]")
TEST_CASE_METHOD(APortfolio, "Answers share count for appropriate symbol", "[Portfolio]")
TEST_CASE_METHOD(APortfolio, "share count reflects accumulated for purchases same symbol", "[Portfolio]")
TEST_CASE_METHOD(APortfolio, "Reduces share count of symbol on sell", "[Portfolio]")
TEST_CASE_METHOD(APortfolio, "Throw when selling more shares than purchased", "[Portfolio]")
```

新增的需求来了：

- **场景：显示买入历史记录**
  - 投资者想看一下特定股票的购买记录，每个记录要显示购买的日期及数量。

就当前实现来说，这个场景开发很困难，因为我们没有跟踪每一笔的交易，更没有记录购买日期。这也是许多开发者对 TDD 质疑的地方。但是如果多花一些时间进行前期的需求分析，那么我们就会知道需要跟踪买日日期，这样在最初的设计就可能纳入这个需求。

但现在已经开发一般，马后炮是没有用的。这个需求场景需要重构，设定好 10 分钟的闹钟，开始。

> 参考代码版本：Git SHA (d4516419538f4adfd5d8f252c10a9e8f37b528ec)

- 先理顺以下需要做的工作：
  - 首先必须定义好表示买入的数据结构、改变方法的参数列表、从客户端代码提供日期、正确地填写数据结构并储存数据。
  - 不过先不要开始，至少不要一口气做完。时刻谨记是否可以增量的进行，每几分钟就寻求一下正面的反馈。例如，让我们先创建一个做出一笔买入的测试，然后验证相应的买入是否在购买记录中。假设买入总是在一个指定的日期做出，因为可以不给 Purchase() 传递日期，这使得目前的任务更简单。

```cpp
TEST_CASE_METHOD(APortfolio, "Answers the purchase record for a single purchase")
{
    using boost::gregorian::date;
    m_portfolio.purchase(SAMSUNG, 5);
    auto purchases = m_portfolio.purchases(SAMSUNG);

    auto purchase = purchases[0];
    REQUIRE(purchase.m_shareCount == 5u);
    REQUIRE(purchase.m_date == Portfolio::FIXED_PURCHASE_DATE);
}
```

为了使测试通过，可以先不需要将买入记录于 holding 数据结构关联。因为目前的假设只考虑单次买入，所以可以定义一个“全局的”买入记录集合：

```cpp
struct PurchaseRecord
{
    PurchaseRecord(unsigned int ShareCount, const boost::gregorian::date& Date)
            : m_shareCount(ShareCount)
            , m_date(Date)
    {
    }

    unsigned int m_shareCount;
    boost::gregorian::date m_date;
};
class Portfolio
{
public:
    static const boost::gregorian::date FIXED_PURCHASE_DATE;

    bool isEmpty() const;

    void purchase(const std::string& Symbol, unsigned int ShareCount);
    void sell(const std::string& Symbol, unsigned int ShareCount);

    unsigned int shareCount(const std::string& Symbol) const;
    std::vector<PurchaseRecord> purchases(const std::string& Symbol) const;

private:
    std::unordered_map<std::string, unsigned int> m_holdings;
    std::vector<PurchaseRecord> m_purchases;
};
```

在继续之前，获得对敲入代码的正面反馈是一件很好的事情。我们定义了一个常量 FIXED_PURCHASE_DATE，以便取得快速的、可以展示的进步。我们知道这是假设的。
