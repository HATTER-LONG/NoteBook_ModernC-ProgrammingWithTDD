# 遗留代码的挑战

- [遗留代码的挑战](#遗留代码的挑战)
  - [遗留代码](#遗留代码)
  - [法则](#法则)
  - [遗留应用程序](#遗留应用程序)
  - [保持测试驱动开发的心态](#保持测试驱动开发的心态)
  - [支持测试的安全重构](#支持测试的安全重构)
  - [添加测试刻画已有行为](#添加测试刻画已有行为)
  - [被遗留代码转移注意力](#被遗留代码转移注意力)
  - [为 rlog 创建测试替身](#为-rlog-创建测试替身)

大部分时间我们需要处理的是遗留了许久的代码，并且很大可能这些代码并没有使用 TDD 的遗留代码，本章的主要内容围绕如何处理这些遗留代码：

- 在没有测试的情况下安全地重构代码的技巧和思路。
- 向已有代码中加入一些测试来描述它们的行为特征，以便测试开发任何所需的改动。
- 样使用链接器存根，以快速摆脱第三方库经常对测试造成的令人头痛的问题。
- 管理大规模代码重构的技巧 ———— Mikado 方法。

## 遗留代码

针对遗留代码的态度，是选择让维护成本不断增加（再函数内增加各种各样的标志和内嵌的代码块）或者着手处理问题？或许大多数时候还是值得一拼的，不允许任何人让系统变得更糟。不值得这么做的唯一情况是，你面对的是一个封闭的系统或即将被淘汰的系统。

## 法则

处理遗留代码问题的核心法则：

1. **任何时候，只要可以就进行测试驱动**。使用测试驱动方法时，有可能的话就将需要改动的代码作为新的成员或新的类。
2. **不要让测试覆盖率缩水**。非常容易出现的情况是，改动一点代码，然后认为这只是一些简单的代码行，并对之不予过多考虑。如果没有测试，每一行新加的代码都会导致测试覆盖率降低。
3. **为了编写测试，必须改动现有代码！**由于对协作对象的依赖，大多数情况下不能方便地为遗留代码编写测试。在编写测试前，需要一个打破依赖的方法。
4. **可以在限制范围内实施微小的代码改动，这样会降低风险**。用一些技巧就可以手动地做出一些小而安全的代码变换。
5. **仔细斟酌再遗留代码上所作的修改**。你编写的每行代码都有风险，甚至一个敲错的字符都会引入潜在的缺陷，而这可能会浪费好几个小时。尽可能少写代码，每敲击一次键盘时都要想清楚。
6. **坚持小的、增量的改动**。这在TDD中是奏效的。同样，对遗留代码也是如此。步子迈得太大会使你陷入困境。
7. **一次只做一件事**。在处理遗留代码时，不要合并步骤或目标。例如，不要在重构的同时写测试。
8. **有些增量的改动可能会使代码变得丑陋，要接受这一点**。记住，一次只做一件事。可能需要几个小时做“正确”的事。不要等，现在就提交工作方案，因为这样或许就不用花费过多时间。最终，你可能要抽出时间回过头来整理代码，或许你不会，但依然是进步了。你已经向正确的方向迈进了，而且也证明了所有代码依然可以工作。
9. **增量地修改代码**。面对庞大的代码库时，仅仅为遇到的相关代码编写测试或许不能带来巨大改观。更重要的是你内心深知任何新加入的东西都需要经过测试。

秉承测试第一的心态，你会开始从加入的测试中获益。每通过一个测试，可以回顾一下测试覆盖的代码区域。几乎总能发现做一些小的、安全的重构工作的机会。同时，你也会发现在写完一个测试后，再写一个是如此容易。你可以在各个地方应用这种小的改善步伐而丝毫不影响产出，也将在困难重重的代码库中如履平地。

## 遗留应用程序

本章将以以下遗留的应用程序为例：

场景: WAV Snippet Publisher
> 为一个内容转销商，我想要 WAV Snippet Publisher 从一个源文件目录下的每个 WAV 文件中抽出一段，然后生成一个新的 WAV 文件，并保存在目标目录下。

客户不断提出新的需求：

场景：添加多通道的支持
> 目前，Snippet publisher 仅能处理单通道 WAV 文件。作为内容转销商，要确保立体声效的 WAV 片段不会被中途截断。

由于 Snippet publisher 并没有使用 TDD，以及其几乎没有单元测试，因此修改其时个巨大的挑战，风险也非常高。

## 保持测试驱动开发的心态

在应对遗留代码时依然是测试先行。即使已经编写完测试所涵盖的代码，仍需要写测试来描述已有行为的特征。同时，也要以 TDD 的方式添加新代码。

只需要测试即将被改动的代码，参考底线会告诉你什么时候破坏了已有的行为。虽然你要判定出哪些依赖代码可能会因此被破坏，但不需要测试超出改动范围的代码。

同时，要避免那些必须与文件系统直接打交道的测试，以便保持测试集快速运行并减少管理文件的烦恼。尽量使用存储于内存的流而非文件流，这样可以部分达成效果。

## 支持测试的安全重构

为了开始对多通道的支持，先找出 open() 函数中有用的功能验证点:[源码路径](https://github.com/HATTER-LONG/TDD_Learning/blob/master/Src/SnippetPublisher/WavReader.cpp)。

根据需求需要支持多通道，发现函数末尾的一段功能代码 —— 总秒数、要写出的采样数目、开始的地方，等等。紧接着计算的是一个for循环，看上去要将采样写入输出文件中，需要修改一些地方支持多通道。

在修改前可以为其编写一些测试，但是如果再 open() 函数中，想要测试到达这部分代码需要许多前期准备。

**与之相反，将循环代码隔离出来（目标代码），放入一个成员函数中，然后直接测试即可。**

P171 查看抽离细节。

至此提取出 writeSamples() 函数，并增强了 open() 函数的抽象度。

## 添加测试刻画已有行为

当我们需要改动 writeSamples() 函数时，从编写测试开始吧！这时就可以开始通过 TDD 来编写我们所需的功能。

## 被遗留代码转移注意力

再本例中有一些第三方库，会为测试制造许多困难。它们要么速度慢，要么需要大量的配置工作，还可能有副作用。如果你是第一次面对遗留代码，很有可能会花费大量时间以处理来自第三方库导致的类似问题。

规避第三方库的一个可行方法是链接替换。就 WavReader 应用而言，我们将创建一个包含存根函数的库，这些函数对应 rlog 中的每个函数，在构建应用可执行文件时，我们会链接到这个库。

链接替换，或链接期替换，听上去比做起来难得多，但其实可以很快建立。

## 为 rlog 创建测试替身
