# 测试驱动开发的其他概念和讨论

- [测试驱动开发的其他概念和讨论](#测试驱动开发的其他概念和讨论)
  - [测试驱动开发与性能](#测试驱动开发与性能)
    - [性能优化测试的策略](#性能优化测试的策略)
    - [相关单元级性能测试](#相关单元级性能测试)
    - [性能和小函数](#性能和小函数)
    - [推荐](#推荐)
  - [单元测试、集成测试和验收测试](#单元测试集成测试和验收测试)
    - [测试驱动开发如何与验收测试建立联系](#测试驱动开发如何与验收测试建立联系)
    - [程序员定义的集成测试](#程序员定义的集成测试)
    - [测试驱动开发和验收测试驱动开发的重合部分](#测试驱动开发和验收测试驱动开发的重合部分)
  - [变换优先级假设](#变换优先级假设)

本章主要讨论以下内容：

1. TDD 和性能：消除对性能的担忧。
2. 集成测试和验收测试：还需要什么类型的测试？它们和单元测试的区别是什么？
3. 变换优先级假设（Transformation Priority Premise，TPP）：这是决定你如何编写下一个测试的正式方法。
4. 三角法：这是驱动编写通用代码的一个技巧。
5. 首先编写断言部分：编写测试的推荐方法。

## 测试驱动开发与性能

本节展示了以测试为中心的策略可以优化性能；讨论了单元级测试如何帮助实现这个策略，以及设计与性能的关联；并强调在尝试解决性能问题之前，应该要先找寻最优设计方案。

一般来说，性能方面的考虑不是功能上的需求。大多都是集成层面的关注点，需要一个集成且部署好的系统。你无法用验证独立逻辑的单元测试来测试这些关注点。

### 性能优化测试的策略

以下是性能优化的通用策略：

1. 依据测试框架构建并运行驱动代码，由此得到系统性能的基准值。
2. 确保测试能正确展示特性的功能——优化系统时很容易破坏系统的功能性。
3. 将驱动代码转变为可以指定当前性能基准的测试。如果某个尝试的优化导致性能下降，那么这个基准测试将会失败。
4. 新增一个目标测试以运行相同的功能，只有性能达到一定要求时测试才会通过。（这可能是基准测试中的第二个断言。）
5. 确定性能瓶颈。
6. 尝试优化与性能瓶颈相关的代码。
7. 确保单元测试和验收测试依然可以通过。
8. 运行基准测试；如果测试失败（换句话说，如果新的性能更糟），那么就放弃当前的改动，然后继续尝试。
9. 运行目标测试，如果测试通过，那就发布吧！
10. 如果目标测试失败，可以尝试通过以下方式解决性能问题：找出第二大的性能瓶颈，尝试提升性能，以此类推。然而，你的优化尝试可能并不合适。更好的方法是记录相对的性能提升，并为代码的改动做上标记。继续找寻另一个优化方案，重复这一过程，检查是否达到了性能目标。

以下是做优化时的一些非常重要的概念：

1. 在与生产目标具有同样特性的机器上运行性能测试。在其他机器上的测试结果可能不能准确地反映出优化对产品的影响，因此，进行这些优化可能会浪费时间，甚至导致性能变得更糟糕。
2. 不做任何假设。对需要优化的地方的直觉往往是错误的。永远要比对优化前后的测试数据。
3. 首先要正确地设计，且仅在此基础上采取优化措施。除非万不得已，否则不要为了引入某些优化而牺牲系统的可维护性和可读性。记住，首先要正确地设计！

### 相关单元级性能测试

单元级性能测试能帮助你沿着 TDD 的方向前行，但无法利用它们来判断是否已经达到性能目标要求。相反，把它们视为工具将帮助你探究这些难题。

在一些罕见的情况下，你可以预先定义单元级的需求，然后利用相关的单元级性能测试（Relative Unit-Level Performance Tests，即 RUPT）来测试驱动这个需求。否则，你将置身于开发之后再测试的领域。

1. 创建一个循环，多次（如 50 000 次）反复执行需要对其进行时间测量的特性。应该消除由启动开销或时钟周期带来的任何差异。还要确认编译器没有优化这些需要计时的特性。
2. 在循环前获取当前的时间戳，并将其存储在变量 start 中。
3. 在执行行为的代码后获取当前的时间戳，并将其存储在变量 stop 中。相对测量值就是 stop 和 start 之间的时间差。
4. 运行 RUPT 并记录时间差。调整循环次数以寻找几秒的时间差。
5. 以数量级的方式增加循环次数。运行测试并确保时间差也是以类似的方式增长。如果不是这样，那么就说明 RUPT 不能准确地表征你的优化尝试。你需要找到原因并修复。
6. 继续多次运行 RUPT。如果时间差的变化非常大，说明这不是一个有效的 RUPT。找到原因并修复，否则，记录平均时间差。
7. 尝试优化代码。
8. 多次运行 RUPT 并记录平均时间差。
9. 如果能获得较大的性能改善，则继续运行性能测试，并调整基准目标。否则，抛弃这些改动。

下面举个栗子：

```cpp
TEST(AGeoServer_Performance, LocationOf) {
    const unsigned int lots{50000};
    addUsersAt(lots, Location{aUserLocation.go(TenMeters, West)});
    TestTimer t;
    for (unsigned int i{0}; i < lots; i++)
        server.locationOf(userName(i));
}

//源码
bool GeoServer::isTracking(const string& user) const {
    return find(user) != locations_.end();
}
Location GeoServer::locationOf(const string& user) const {
    if (!isTracking(user)) return Location{}; // 性能开销? 这里进行了两次 find 操作
        return find(user)->second;
}
```

循环 50000 此记录下平均运行时间。然后将循环次数扩大到 500000 并多次运行测试，记录平均时间，期望的结果应该是时间大致成比例增长。（如果没有效果，需要找到一种方式阻止 c++ 编译器进行的循环优化操作）。

接下来优化代码：

```cpp
Location GeoServer::locationOf(const string& user) const {
    // 优化后
    auto it = find(user);
    if (it == locations_.end()) return Location{};
        return it->second;
}
```

现在的问题是，它是有用的吗？基于这一点，我们将运行基准性能测试和目标性能测试，并判断这个优化是否是必需的。如果该优化不是必需的，只是让代码变得更复杂，那么就删除这个优化。

保留该优化的代价看起来很小。locationOf() 函数仅仅将一行代码变成了三行代码。很多有用的优化往往会增加很多相当难以解释和维护的代码。

清晰的设计从两个方面对性能优化有所帮助。首先，当拥有简洁的函数定义时，用分析工具更容易查明性能问题所在。其次，简洁的类和函数可以帮助你思考出富有创意的优化方法。一旦找出问题所在，改动代码也会变得更轻松。

### 性能和小函数

小函数的另一个有趣方面是，C++编译器很有可能在一开始就将其变成内联函数。对较大的函数来说，这实际上减少了编译器优化代码的机会。

事实上，不将部分代码抽取出来并放进较小的函数中代表着不好的设计，而且它实际上并不能提高应用程序的性能。性能方面的专家早就知道这一点。

### 推荐

1. 一个稳固的架构：架构一词意味着，一旦就绪就不要轻易改变方方面面的布局。例如，各个模块之间的流程关系图（分布在服务器端和客户端），架构如何在不修改代码的基础上支持不同配置的硬件（换句话说，通过扩充硬件的方式）？
2. 一个拥有简洁代码、稳固且灵活的设计，以及在需要大规模修改代码时能提供灵活性的测试。
3. 一组从一开始就定义好的、关于未来性能期望的性能目标测试。如果你希望在前期将应用程序发布给十几位用户，而最终用户数量达到一百位，你需要立即知道在新的代码中是否因用户数目的变化而存在风险。

有些代码级的优化的确可以归到自由的范畴。比如，在C++中，用引用传递比用值传递的效率更高，且不影响代码的表达性。如果这些优化没有降低可读性或易维护性，那就去看看吧。否则，就留待以后（很久以后）再研究吧。

## 单元测试、集成测试和验收测试

单元指的是一个小而独立，且能影响某些系统行为的逻辑片段。定义中的独立表明，你可以单独运行这个逻辑单元。这要求去除该逻辑单元对其他模块（如服务调用、应用程序接口、数据库、文件系统，等等）的依赖关系。单元测试对于驱动开发测试的重要意义在于，它能快速修改和调整。

因此仅仅靠单元测试是不够的。因为它们仅仅验证了那些细小的、相互独立的代码片段，无法验证端对端或已部署方案的正确性。

系统还需要其他测试，其中包含了系统测试、客户测试、验收测试、负载测试、性能测试、可用性测试、功能测试以及可扩展性测试（有些测试大同小异）。因为所有这些测试都是基于集成的软件产品进行验证的，所以都是**集成测试**。

### 测试驱动开发如何与验收测试建立联系

通过预先定义验收测试的方式来驱动系统的开发流程，以及通过使用TDD来驱动一些逻辑模块的开发流程，这二者是非常类似的。实际上，采用验收测试的团队称这种流程为验收测试驱动开发（Acceptance Test–Driven Development，ATDD）。

TDD 与 ATDD 的重要区别在于，谁定义了这些测试以及谁会使用这些测试。

- 对 TDD 而言，程序员负责用编程语言定义单元测试。因此，即将阅读或者使用这些测试的人毫无疑问就是程序员本身（但这并不意味着你可以毫不关心他们代码的可阅读性）。
- 对 ATDD 而言，客户（可能也包含了产品负责人或商业分析员）负责根据商业需求定义验收测试。他们绝不是凭空捏造。创建健壮的验收测试，需要团队包括测试员和程序员在内的其他人员的意见与信息。每个人都会使用基于 ATDD 的测试。

### 程序员定义的集成测试

一些精挑细选的集成测试是非常有价值的，而且公司可能也需要。可以直接测试数据访问层以获得更多的即时信息以及关于代码和数据储存定义之间差异性的故障信息，也可以使用一组冒烟测试来快速判断部署的配置是否正确。

然而，**集成测试很难维护**。因为集成测试应对的软件被部署在定制的环境中，需要和外部服务和数据存储的野蛮世界进行交互，所以它们是脆弱的。始终保持测试最新且可以在所有的部署环境中运行是巨大的挑战。

**最好只编写所需要的集成测试，而不是越多越好**。抽出时间分类集成测试，对每个测试采取以下四个动作中的一个：

1. 清理集成测试，并将其作为验收测试出售；
2. 通过移除对其他逻辑模块的依赖，将其转变为一个快速的单元测试；
3. 将其作为勉强保留的集成测试；
4. 删除它。

### 测试驱动开发和验收测试驱动开发的重合部分

当团队同时基于 TDD 和 ATDD 开展工作时，一个令人焦虑的事情是有些测试不可避免地会出现重叠现象，尤其是当所有任务都是正确的、通过测试驱动模式完成的情况下。绝大多数验收测试通常代表一些功能上的兴趣点，并且展示了系统如何和其他系统进行交互。在做 TDD 时，你也将通过测试驱动用户接口层的开发。这是重复的劳动吗？

的确，基于接口层的测试看起来非常类似。然而，测试的受众和目的是完全不同的。没有人会阅读你的程序员测试。相反，设计验收测试就是让任何人都可以读取。

从设计的角度来说，重复的代码量应该要很小。在设计良好的系统中，用户接口层非常薄，主要作为商业领域类（这里应该还有许多非用户接口层的类）的代表。因此，针对这些用户接口层的单元测试，仅仅需要验证任务被正确地授权。

单纯地从测试的角度来看，同时拥有单元测试和验收测试的好处是，提供了一层额外的保护。

缺陷意味着有错误的或遗漏掉的单元测试。可以通过测试驱动的方式弥补缺陷。先编写一个可以重现故障的测试，然后修改代码使单元测试（以及任何相关的其他验收测试）通过。

## 变换优先级假设

TODO 待完成剩余
