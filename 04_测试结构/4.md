# 测试结构

- [测试结构](#测试结构)
  - [前言](#前言)
  - [组织方式](#组织方式)
    - [文件组织](#文件组织)
    - [fixture](#fixture)
    - [Setup 与 Teardown](#setup-与-teardown)
    - [Arrange-Act-Assert/Given-When-Then](#arrange-act-assertgiven-when-then)
    - [快速测试、慢速测试、过滤器和测试集](#快速测试慢速测试过滤器和测试集)
      - [运行测试的一个子集](#运行测试的一个子集)

## 前言

本章将深入讨论实现测试的具体细节，包括：文件组织、fixture、setup、teardown、过滤器、断言和基于异常的断言。

## 组织方式

从文件和逻辑方面着眼，组织测试的方式有几种：

1. fixture 方式，以及如何利用 setup 和 teardown 钩子函数。
2. 如何使用 Given-When-Then 的概念来组织。

### 文件组织

在测试驱动开发相关行为时，我们会将相关的测试定义在同一个测试文件中。最终可能需要多个测试文件来验证相关行为，也可能需要用一个测试文件覆盖多个地方行为，所以**不用拘泥于一个类一个测试文件的形式**。

基于所包含的测试来给文件命名。概括相关的行为，并据此给测试命名。选定一个命名体系诸如`BehaviorDescriptionTest.cpp`、`BehaviorDescriptionTests.cpp` 或者 `TestBehaviorDescription.cpp`。

### fixture

大多数单元测试工具都支持将逻辑上相关的测试分组。再 Google Mock 以及 Catch2 中都支持所谓的测试用例名称来将相关测试分组。下面的测试所属的测试用例名为 ARetweetCollection。IncrementsSizeWhenTweetAdded 是此测试用例中的一个测试。

```cpp
//google mock
TEST(ARetweetCollection, IncrementsSizeWhenTweetAdded)

//catch2
TEST_CASE("IncrementsSizeWhenTweetAdded","[ARetweetCollection]")
```

相关的测试运行时需要相同的环境，例如许多测试都需要公共的初始化或者符主函数，许多测试工具能够使你定义一个 fixture -- 一个跨测试可重用的类。

```cpp
//google mock
class ARetweetCollection: public Test 
{
public:
    RetweetCollection collection;
};

TEST_F(ARetweetCollection, IsEmptyWhenCreated) 
{
    ASSERT_THAT(collection.isEmpty(), Eq(true));
}

TEST_F(ARetweetCollection, IsNoLongerEmptyAfterTweetAdded) 
{
    collection.add(Tweet());
    ASSERT_THAT(collection.isEmpty(), Eq(false));
}

//catch2
class FixtureSoundex
{
public:
    Soundex MSoundex;
};

TEST_CASE_METHOD(FixtureSoundex, "Retain sole letter of one letter world", "[SoundexEncoding]")
{
    REQUIRE_THAT(MSoundex.encode("A"), Equals("A000"));
}
```

### Setup 与 Teardown

如果测试用例中的所有测试需要一条或更多的相同初始化语句，那么可以将它们写在 fixture 类的初始化函数中。在 Google Mock 中，必须将此函数命名为 SetUp（它覆写了基类 ::testing::Test 中的虚函数）。

```cpp
//google mock
class ARetweetCollectionWithOneTweet: public Test {
public:
    RetweetCollection collection;
    void SetUp() override {
        collection.add(Tweet());
    }
};
TEST_F(ARetweetCollectionWithOneTweet, IsNoLongerEmpty) {
    ASSERT_FALSE(collection.isEmpty());
}
TEST_F(ARetweetCollectionWithOneTweet, HasSizeOfOne) {
    ASSERT_THAT(collection.size(), Eq(1u));
}
```

再 Catch2 中使用了不同的方式，来进行共有代码初始化与释放，即 SECTION 机制，每个 SECTION 都是再测试开始阶段运行，不受其他 SECTION 段影响，更强的是它支持 SECTION 中继续嵌套 SECTION 来更加精细的适配不同测试所需的前置条件：

```cpp
//catch2
TEST_CASE( "vectors can be sized and resized", "[vector]" ) {

    std::vector<int> v( 5 );

    REQUIRE( v.size() == 5 );
    REQUIRE( v.capacity() >= 5 );

    SECTION( "resizing bigger changes size and capacity" ) {
        v.resize( 10 );

        REQUIRE( v.size() == 10 );
        REQUIRE( v.capacity() >= 10 );
    }
    SECTION( "resizing smaller changes size but not capacity" ) {
        v.resize( 0 );

        REQUIRE( v.size() == 0 );
        REQUIRE( v.capacity() >= 5 );
    }
    SECTION( "reserving bigger changes capacity but not size" ) {
        v.reserve( 10 );

        REQUIRE( v.size() == 5 );
        REQUIRE( v.capacity() >= 10 );

        SECTION( "reserving smaller again does not change capacity" ) {
            v.reserve( 7 );

            REQUIRE( v.capacity() >= 10 );
        }
    }
}
```

初始化的代码适用于所有相关的测试。如果只用少数几个测试来设置上下文反而容易造成不必要的困惑。当一些测试需要一个初始化代码块，而其他测试不需要时，最好再创建一个初始化块，并且把测试合理地分开。

在创建额外的 fixture 时，不要犹豫。但是每创建一个 fixture，判断一下是不是需要显现出产品代码中的设计缺陷。**如果需要两个不同的 fixture 的话，这有可能意味着你正在测试的类违反了单一责任原则，你可能需要将它们拆分为两个类。**

### Arrange-Act-Assert/Given-When-Then

测试都有相同的流程。首先需要设置好合适的条件，然后执行代表要验证的行为的代码，最后验证结果是否和期望的一样。

测试应当尽可能地直接反映其测试意图。这就意味着阅读测试的人不需要细细品读测试中的每一行，就能很容易地理解测试的基本构成：测试的初始化（Arrange）、测试的行为（Act），以及怎样验证行为结果（Assert）。例如以下代码，使用 AAA 的区别：

```cpp
TEST_F(ARetweetCollection, IgnoresDuplicateTweetAdded) {
    Tweet tweet("msg", "@user");
    Tweet duplicate(tweet);
    collection.add(tweet);
    collection.add(duplicate);
    ASSERT_THAT(collection.size(), Eq(1u));
}
//VS

TEST_F(ARetweetCollection, IgnoresDuplicateTweetAdded) {
    Tweet tweet("msg", "@user");
    Tweet duplicate(tweet);
    collection.add(tweet);

    collection.add(duplicate);

    ASSERT_THAT(collection.size(), Eq(1u));
}
```

再 Catch2 中还支持另一种方式 Given-When-Then。给定（Given）一个上下文，当（When）
测试调用一些行为，然后（Then）验证结果。Given-When-Then 表述法稍微侧重强调验证行为，而非测试执行。这里的 SCENARIO 与 TEST_CASE 没有区别，从命名上更符合 GWT 语义。

```cpp
SCENARIO( "vectors can be sized and resized", "[vector]" ) {

    GIVEN( "A vector with some items" ) {
        std::vector<int> v( 5 );

        REQUIRE( v.size() == 5 );
        REQUIRE( v.capacity() >= 5 );

        WHEN( "the size is increased" ) {
            v.resize( 10 );

            THEN( "the size and capacity change" ) {
                REQUIRE( v.size() == 10 );
                REQUIRE( v.capacity() >= 10 );
            }
        }
        WHEN( "the size is reduced" ) {
            v.resize( 0 );

            THEN( "the size changes but not capacity" ) {
                REQUIRE( v.size() == 0 );
                REQUIRE( v.capacity() >= 5 );
            }
        }
    }
}
```

### 快速测试、慢速测试、过滤器和测试集

如果编写的是小而独立的代码单元，那么每个测试都会运行得快如闪电。通常一个测试在一台配置完备的电脑上的运行时间不到一毫秒。以这种速度，几分钟内至少可以运行几千个测试。如果与一些外部慢速资源（如数据库或其他慢速服务）交互的话，那么测试就会变慢。单单建立数据库连接就可能花费50毫秒。如果大部分测试必须与数据库交互，那么需要几分钟才能运行完几千个测试。有些工作室需要半个多小时才能运行完所有测试。

而 TDD 的核心目标就是尽可能频繁地获得较多的反馈。当修改了一点代码时，会马上想知道改动是否正确，影响到了其他代码？这时如果运行测试时间很长，那么就不会频繁的运行他们，一旦反馈周期变长，TDD 的威力就急剧减弱。因为越晚察觉到的问题，修改所需的耗费就更长。

运行慢的测试对 TDD 来说是个问题，所以一些人不再把它们称为单元测试，而是称其为集成测试。

#### 运行测试的一个子集

