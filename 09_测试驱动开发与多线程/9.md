# 测试驱动开发与多线程

- [测试驱动开发与多线程](#测试驱动开发与多线程)
  - [测试驱动开发多线程应用的核心概念](#测试驱动开发多线程应用的核心概念)
  - [示例程序 GeoServer](#示例程序-geoserver)
  - [性能要求](#性能要求)
  - [设计异步方案](#设计异步方案)

## 测试驱动开发多线程应用的核心概念

1. **分离线程逻辑和程序逻辑**：最好的面向对象的设计是尽可能地分离各种关注点。多线程应用程序设计也不例外。多线程是一个关注点，应用程序逻辑是另一个关注点。要尽可能地分离这些关注点，并将耦合降到最低。

2. **休眠方案很糟糕**：在线程中通过调用sleep_for()暂停执行，直到满足相应的条件，这种方案很糟糕。测试的运行会变慢，还会引发随机错误。更糟糕的是，真正的问题会被隐藏得更深、更久。

3. **简化特定的应用测试至单线程**：在引入多线程之前，应用程序代码首先确保必须能够再单线程环境下工作。为特定的应用测试提供消除并发性的方法，可以帮助你保持清醒。测试多线程往往最终会产生速度较慢的集成测试领域。

4. **在引入并发性控制之前，验证并发性问题**：在程序中滥用并发控制（Lock 和 Wait 即 同步）会极大降低应用程序的性能，甚至有可能解决不了任何真正的并发性问题。接下来的示例程序主要包含了以下核心内容：先编写一个可以演示潜在并发性问题的测试；`然后使其恶化，直到测试每次都会失败。`通过演示这些失败，首先能确保继续保持测试驱动的模式。你需要做的仅仅是增加并发性控制，以便测试可以通过。

## 示例程序 GeoServer

GeoServer 为客户端应用程序提供了一些支持，以跟踪大量用户的地理位置典型的客户端应用是基于地图的手机应用程序。

> 版本：d7ea5c555dd8f1a4fb8d3c832fe4331937721f5b

[GerServer 源码](https://github.com/HATTER-LONG/TDD_Learning/tree/master/Src/GeoServer)

基于这些基本源码素材，新增需求：

场景：搜索附近的用户
> 作为客户端用户，我希望能够标识出地图上某个矩形区域内的所有用户（包括他们的坐标），这样就能知道他们在地图上的位置了

我们将在 GeoServer 中实现这一点。其中 Area 表示以某个位置为中心的矩形区域，能够表明该区域是否包含了一个（或其他）位置。
> 版本：92321c96a0d4a56bbf4e731898a966a718bf2d4c

## 性能要求

我们面临性能方面的考验。产品负责人指出我们期望大量的用户。初始发行版本应该可以同时支持50 000位用户。

编写以下测试用来模拟将用户数目逐步增值巨大数量级：

> 版本：85e7273736f1b3b6180ef0fff62622f7ffba82eb

```cpp
TEST_CASE_METHOD(FixtureUserInBox, "Handles large numbers of users", "[AGeoServer_UsersInBox]")
{
    Location anotherLocation { aUserLocation.go(10, West) };
    const unsigned int lots { 500000 };
    for (unsigned int i { 0 }; i < lots; i++)
    {
        string user { "user" + to_string(i) };
        server.track(user);
        server.updateLocation(user, anotherLocation);
    }

    auto users = server.usersInBox(aUser, Width, Height);
    REQUIRE(lots == users.size());
}
```

可以发现在执行此测试会有明显的时间消耗：

```shell
~
❯ /home/caolei/WorkSpace/TDD_Learning/build/test/catch2_GeoServerTest -d yes
0.000 s: Tracks m_aUser
0.000 s: Is not tracking m_aUser not tracked
0.000 s: Tracks multiple users
0.000 s: Is tracking answers false when user no longer tracked
0.000 s: Updates location of user
0.000 s: Answers unknown location for user not tracked
0.000 s: Answers unknown location for tracked user with no location update
0.000 s: Answers unknown location for user no longer tracked
0.000 s: Answers users in specified range
0.000 s: Answers only users within specified range
0.580 s: Handles large numbers of users
===============================================================================
All tests passed (14 assertions in 11 test cases)
```

虽然看起来并不长，但这仅仅只是一个测试。一个系统中最终可能会有成千上万个测试，即便只有少量运行缓慢的测试，但也会阻碍你按照必要的频率来运行这些测试。。我们并不想在快速测试集中运行较慢的 HandlesLargeNumbersOfUsers 测试。但我们将来仍然有可能需要运行它。完成清理工作之后，最好的措施就是将 HandlesLargeNumbersOfUsers 移到运行较慢的其他测试集中。

但是我们最好确定是什么导致测试运行缓慢：

```cpp
TEST_CASE_METHOD(FixtureUserInBox, "Handles large numbers of users",
    "[.][Slow][AGeoServer_UsersInBox_Slow][AGeoServer_UsersInBox]")
{
    Location anotherLocation { aUserLocation.go(10, West) };
    const unsigned int lots { 500000 };
    for (unsigned int i { 0 }; i < lots; i++)
    {
        string user { "user" + to_string(i) };
        server.track(user);
        server.updateLocation(user, anotherLocation);
    }
    Catch::Timer timer;
    auto beforeUsersInBox = timer.getElapsedMilliseconds();
    CAPTURE(beforeUsersInBox);
    //这里使用时间来测试是否为调用耗时
    auto users = server.usersInBox(aUser, Width, Height);

    auto afterUsersInBox = timer.getElapsedMilliseconds();
    CAPTURE(afterUsersInBox);

    REQUIRE(lots == users.size());
}
```

```shell
~
❯ /home/caolei/WorkSpace/TDD_Learning/build/test/catch2_GeoServerTest -s  -d yes "[AGeoServer_UsersInBox_Slow]"
Filters: [AGeoServer_UsersInBox_Slow]

........

catch2_GeoServerTest elapsed time = 133.654ms
0.582 s: Handles large numbers of users
===============================================================================
All tests passed (1 assertion in 1 test case)
```

虽然 133 毫秒没有半秒那么严重，但产品负责人对此并不满意。我们和她讨论各种可行方案，一起构造出一个可以满足需求的场景。

场景：搜索附近用户是一个异步的需求
>作为客户端用户，我期望“搜索附近用户”的需求能够迅速得到反馈。我想逐个地收到附近用户的信息，每收到一个就在地图上显示出来。

你可能已经意识到这些场景并非是技术上的。现存的指导方针将避免创建不对商业提供可验证价值的场景。

## 设计异步方案

