# 高质量测试

- [高质量测试](#高质量测试)
  - [测试先行](#测试先行)
    - [快速 FAST](#快速-fast)
    - [独立 Isolated](#独立-isolated)
    - [可重复](#可重复)
    - [自我验证](#自我验证)
    - [及时](#及时)

本章将学习如何设计测试，以便提升回报并避免其成为维护负担。本章将介绍以下几个方法：

1. FIRST 助记符---审核测试的重要方法。
2. 一个测试一个断言---版主限制测试的大小准则。
3. 测试抽象---保持测试可读性的核心原则。

## 测试先行

可以通过对照 FIRST 原则来审视编写的测试是否足够好：

- F 是快速（Fast）；
- I 是独立（Isolated）；
- R 是可重复（Repeatable）；
- S 是自我验证（Self-verifying）；
- T 是及时（Timely）。

### 快速 FAST

通过规定、构建、重构的核心周期，TDD 支持增量和迭代的开发方式，每个周期应当越短越好，当代码出现问题或者破坏了其他功能，你应当迅速了解，可以迅速的修复。

必须确保所修改的或新加的测试可以通过，且所做的改动不会破坏系统中的其他代码。**每做一次小的改动，就要运行一下所有的单元测试。**

想要获得更多的测试反馈，保持周期的低开销，即编译、运行所耗费的时间越低越好，这样开发者才会频繁的执行测试获取更多的反馈。

1. 构建的开销
    - 大部分构建时间与代码的依赖结构直接相关。依赖于改动的代码必须重新编译。按照接口隔离原则，迫使客户端程序依赖一个它们不用的接口意味着存在设计缺陷。
    - 改善依赖关系的方式：
      - 依赖倒置原则：依赖抽象，而非实现细节。引入一个接口——一个纯虚空类，由一个具体类来实现。如果改动具体类的实现细节，客户端程序通过接口提供的抽象与其交互，且不会触发客户端程序的重编译。
      - PIMPL（指针实现）方式：将具体的实现细节提取成一个独立的实现类。将来自接口的调用委托给这个实现类。然后就可以自由地改变实现、随心所欲地创建新的函数了，而不用重新编译依赖公开接口的代码。

2. 对协作者的依赖
    - 依赖改动会增加编译时间。为了运行这些测试，对依赖的担忧开始发生转变：在测试其他代码时产生的依赖增加了测试的执行时间。如果测试代码和另外一个类交互，且这个类必须调用外部 API（如一个数据库调用），那么测试必须等待 API 调用完成。
    - 改善协作者依赖的方式：
      - MOCK 替代掉慢速的协作者，但是也要注意不要滥用 MOCK，谨记每次使用 MOCK 都对应者你的代码测试覆盖率在下降。

3. 运行一个测试集：
    - 想要加快测试运行的速度，指定运行某一个测试子集也是个办法，虽说它并不是一个好习惯，例如破坏了其他子集测试所覆盖的代码而你不会及时的察觉到。
    - 当不能容易地运行所有测试时，不要立刻一次只运行一个测试。要找到一次运行尽可能多的测试的方法。至少在一次运行一个测试前，尝试在特定fixture（如Holding*.*）下运行所有的测试。
    - **在初期运行测试的子集或许能节省点时间，但请记住，运行的测试越少，今后发现的问题就会越多，进而也就需要更多时间来进行修复。**

### 独立 Isolated

使用 TDD 创建的测试应该只由一个原因导致失败方便问题的查找。小而集中的测试可以驱动开发出一小段行为，从而增加了独立性。

每个测试应该验证一小段独立于外部因素的逻辑。如果测试所验证的代码要与数据库、文件系统或其他的API交互，那么导致测试失败的因素可以是很多种。引入测试替身（参见第5章）可以获得独立性。

测试不仅要独立于产品系统的外部因素，还要彼此独立。使用静态数据的所有测试都可能因为旧的数据而失败。

如果测试需要大量的前置设置，可以将所有重要的前置条件通过断言验证后在执行测试，例如：

```cpp
TEST_F(ACheckedInHolding, UpdatesDateDueOnCheckout)
{
    ASSERT_TRUE(IsAvailableAt(holding, *arbitraryBranch));
    holding->CheckOut(ArbitraryDate);
    ASSERT_THAT(holding->DueDate(),
    Eq(ArbitraryDate + date_duration(Book::BOOK_CHECKOUT_PERIOD)));
}
```

如果前置条件断言失败，你会少浪费些时间查找、修复问题。但是，如果发现要经常使用这一技巧，还是找一个简化设计的方法吧——前置条件断言意味着你对系统的理解还不够，**也意味着你在设置阶段隐藏太多的信息。**

### 可重复

高质量的单元测试是可重复的，即可以一遍遍地运行，并且总是获得相同的结果，无论其他测试（如果有的话）是否先运行。

- 间歇性的测试失败不是一件好事。这意味着一定程度上的不确定性或测试运行中存在异常行为。找到异常行为的原因可能需要大量的精力，下列是可能导致测试间歇性失败的原因：
  1. *静态数据*：好的单元测试不会依赖其他测试的影响，也不会让残留的状态造成问题。在一些单元测试框架中，测试被添加到基于哈希的集合中，执行的顺序可能随着测试数量的变化而改变，因此测试之间不应该互相依赖执行顺序。
  2. *不稳定的外部服务*：避免编写依赖于你控制不了的外在因素的单元测试，如当前时间、文件系统、数据库以及其他一些API调用。可在必要时引入 mock 打破依赖。
  3. *程序并发*：多线程或其他多道执行技术会引入一些不确定的行为，这对单元测试而言可能是极大的挑战。

### 自我验证

单元测试必须执行代码并验证代码能否在你不参与的情况下自动工作。一个单元测试至少有一个断言。它必须在其存在的周期里至少失败一次，未来也必须有一些方法让它失败。不要在测试中加入cout语句来替代断言。手动的控制台验证或日志文件输出既浪费时间也增加风险。

### 及时

什么时候编写测试？及时编写意味着你要先编写测试。为什么？因为你在做TDD，而且正是因为它是保持高质量代码库的最好方法，所以你才使用它。

同样，不要在编写代码前编写一堆测试。相反，每次只写一个测试，甚至在每个测试中一次只加入一个断言。要尽可能地增量化，将每个测试视作一小段规范，让你可以快速驱动一致的行为。
