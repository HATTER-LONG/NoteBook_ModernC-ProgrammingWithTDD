# 高质量测试

- [高质量测试](#高质量测试)
  - [测试先行](#测试先行)
    - [快速 FAST](#快速-fast)
    - [独立 Isolated](#独立-isolated)
    - [可重复](#可重复)
    - [自我验证](#自我验证)
    - [及时](#及时)
  - [一个测试一个断言](#一个测试一个断言)
  - [测试抽象](#测试抽象)
    - [臃肿的初始化](#臃肿的初始化)
    - [不相关的细节](#不相关的细节)
    - [缺失的抽象](#缺失的抽象)
    - [多重断言](#多重断言)
    - [不相关的数据](#不相关的数据)
    - [不必要的测试代码](#不必要的测试代码)

本章将学习如何设计测试，以便提升回报并避免其成为维护负担。本章将介绍以下几个方法：

1. FIRST 助记符---审核测试的重要方法。
2. 一个测试一个断言---版主限制测试的大小准则。
3. 测试抽象---保持测试可读性的核心原则。

## 测试先行

可以通过对照 FIRST 原则来审视编写的测试是否足够好：

- F 是快速（Fast）；
- I 是独立（Isolated）；
- R 是可重复（Repeatable）；
- S 是自我验证（Self-verifying）；
- T 是及时（Timely）。

### 快速 FAST

通过规定、构建、重构的核心周期，TDD 支持增量和迭代的开发方式，每个周期应当越短越好，当代码出现问题或者破坏了其他功能，你应当迅速了解，可以迅速的修复。

必须确保所修改的或新加的测试可以通过，且所做的改动不会破坏系统中的其他代码。**每做一次小的改动，就要运行一下所有的单元测试。**

想要获得更多的测试反馈，保持周期的低开销，即编译、运行所耗费的时间越低越好，这样开发者才会频繁的执行测试获取更多的反馈。

1. 构建的开销
    - 大部分构建时间与代码的依赖结构直接相关。依赖于改动的代码必须重新编译。按照接口隔离原则，迫使客户端程序依赖一个它们不用的接口意味着存在设计缺陷。
    - 改善依赖关系的方式：
      - 依赖倒置原则：依赖抽象，而非实现细节。引入一个接口——一个纯虚空类，由一个具体类来实现。如果改动具体类的实现细节，客户端程序通过接口提供的抽象与其交互，且不会触发客户端程序的重编译。
      - PIMPL（指针实现）方式：将具体的实现细节提取成一个独立的实现类。将来自接口的调用委托给这个实现类。然后就可以自由地改变实现、随心所欲地创建新的函数了，而不用重新编译依赖公开接口的代码。

2. 对协作者的依赖
    - 依赖改动会增加编译时间。为了运行这些测试，对依赖的担忧开始发生转变：在测试其他代码时产生的依赖增加了测试的执行时间。如果测试代码和另外一个类交互，且这个类必须调用外部 API（如一个数据库调用），那么测试必须等待 API 调用完成。
    - 改善协作者依赖的方式：
      - MOCK 替代掉慢速的协作者，但是也要注意不要滥用 MOCK，谨记每次使用 MOCK 都对应者你的代码测试覆盖率在下降。

3. 运行一个测试集：
    - 想要加快测试运行的速度，指定运行某一个测试子集也是个办法，虽说它并不是一个好习惯，例如破坏了其他子集测试所覆盖的代码而你不会及时的察觉到。
    - 当不能容易地运行所有测试时，不要立刻一次只运行一个测试。要找到一次运行尽可能多的测试的方法。至少在一次运行一个测试前，尝试在特定fixture（如Holding*.*）下运行所有的测试。
    - **在初期运行测试的子集或许能节省点时间，但请记住，运行的测试越少，今后发现的问题就会越多，进而也就需要更多时间来进行修复。**

### 独立 Isolated

使用 TDD 创建的测试应该只由一个原因导致失败方便问题的查找。小而集中的测试可以驱动开发出一小段行为，从而增加了独立性。

每个测试应该验证一小段独立于外部因素的逻辑。如果测试所验证的代码要与数据库、文件系统或其他的API交互，那么导致测试失败的因素可以是很多种。引入测试替身（参见第5章）可以获得独立性。

测试不仅要独立于产品系统的外部因素，还要彼此独立。使用静态数据的所有测试都可能因为旧的数据而失败。

如果测试需要大量的前置设置，可以将所有重要的前置条件通过断言验证后在执行测试，例如：

```cpp
TEST_F(ACheckedInHolding, UpdatesDateDueOnCheckout)
{
    ASSERT_TRUE(IsAvailableAt(holding, *arbitraryBranch));
    holding->CheckOut(ArbitraryDate);
    ASSERT_THAT(holding->DueDate(),
    Eq(ArbitraryDate + date_duration(Book::BOOK_CHECKOUT_PERIOD)));
}
```

如果前置条件断言失败，你会少浪费些时间查找、修复问题。但是，如果发现要经常使用这一技巧，还是找一个简化设计的方法吧——前置条件断言意味着你对系统的理解还不够，**也意味着你在设置阶段隐藏太多的信息。**

### 可重复

高质量的单元测试是可重复的，即可以一遍遍地运行，并且总是获得相同的结果，无论其他测试（如果有的话）是否先运行。

- 间歇性的测试失败不是一件好事。这意味着一定程度上的不确定性或测试运行中存在异常行为。找到异常行为的原因可能需要大量的精力，下列是可能导致测试间歇性失败的原因：
  1. *静态数据*：好的单元测试不会依赖其他测试的影响，也不会让残留的状态造成问题。在一些单元测试框架中，测试被添加到基于哈希的集合中，执行的顺序可能随着测试数量的变化而改变，因此测试之间不应该互相依赖执行顺序。
  2. *不稳定的外部服务*：避免编写依赖于你控制不了的外在因素的单元测试，如当前时间、文件系统、数据库以及其他一些API调用。可在必要时引入 mock 打破依赖。
  3. *程序并发*：多线程或其他多道执行技术会引入一些不确定的行为，这对单元测试而言可能是极大的挑战。

### 自我验证

单元测试必须执行代码并验证代码能否在你不参与的情况下自动工作。一个单元测试至少有一个断言。它必须在其存在的周期里至少失败一次，未来也必须有一些方法让它失败。不要在测试中加入 cout 语句来替代断言。手动的控制台验证或日志文件输出既浪费时间也增加风险。

### 及时

什么时候编写测试？及时编写意味着你要先编写测试。为什么？因为你在做TDD，而且正是因为它是保持高质量代码库的最好方法，所以你才使用它。

同样，不要在编写代码前编写一堆测试。相反，每次只写一个测试，甚至在每个测试中一次只加入一个断言。要尽可能地增量化，将每个测试视作一小段规范，让你可以快速驱动一致的行为。

## 一个测试一个断言

在系统中测试驱动开发小而不相关联的行为，而规定行为以及验证此行为确实可行的方法——断言。另外测试必须清楚地陈述意图，而意图最重要的声明是测试名称，它应该澄清上下文和目标。

因此当一个测试覆盖的行为越多，测试名称就越不能准确的描述行为。多个行为揉进一个测试，在一定程度上将它们绑在了一起。你可能发现许多方法会和其他方法一同使用，这意味着找出哪个方法是哪个测试所测是相当困难的。最主要的缺点便是阅读的人需要花费更多的时间弄清楚怎么回事，因此推荐一个 TEST_F 或者 SECTION，中仅仅包含一个断言。

但也不要过于死板，有时一个行为可能由多个参数需要验证，这时引入多个断言完全合理。

要谨记一个关键的准则——一个测试只有一个行为。如果还不够清楚，那么可以这样认为，任何拥有条件逻辑（如if语句）的测试几乎都与此准则相悖。

## 测试抽象

抽象在测试和面向对象设计中同等重要。因为你要将测试当作文档来读，所以它们必须正中其意，以最清晰、最简洁的方式声明其意图。可以通过以下几个途径增加测试的抽象程度：

1. 内聚：一个测试一个断言；
2. 更好的命名：测试自身及内部的代码；
3. 抽象掉多余的东西：可利用 fixture 辅助函数或者 SetUp()。

### 臃肿的初始化

以下列代码为例：

```cpp
TEST(LineReaderTest, OneLine) {
    const int fd = TemporaryFile();
    write(fd, "a", 1);
    lseek(fd, 0, SEEK_SET);
    LineReader reader(fd);
    const char *line;
    unsigned len;
    ASSERT_TRUE(reader.GetNextLine(&line, &len));
    ASSERT_EQ(len, (unsigned)1);
    ASSERT_EQ(line[0], 'a');
    ASSERT_EQ(line[1], 0);
    reader.PopLine(len);
    ASSERT_FALSE(reader.GetNextLine(&line, &len));
    close(fd);
}
```

测试的前三行创建了一个临时文件，并在文件里写入了一个字符（"a"），然后将文件指针指向文件头部。这个臃肿的构造需要阅读测试的人看一些无关紧要的测试设置细节。可以用一行抽象来替代它。

```cpp
TEST(LineReaderTest, OneLine) {
    const int fd = WriteTemporaryFile("a");
    LineReader reader(fd);
    const char *line;
    unsigned len;
    ASSERT_TRUE(reader.GetNextLine(&line, &len));
    ASSERT_EQ(len, (unsigned)1);
    ASSERT_EQ(line[0], 'a');
    ASSERT_EQ(line[1], 0);
    reader.PopLine(len);
    ASSERT_FALSE(reader.GetNextLine(&line, &len));
    close(fd);
}
```

测试变短了几行，而且隐藏了创建一个有少量数据的文件的实现细节。一般不需要关心这个，极少数需要的情况下，可以浏览来了解 WriteTemporaryFile() 到底做了什么。

### 不相关的细节

将测试过程中不需要他人理解、无用的细节，可以移到 fixture 的初始化和清理中，同时重复的代码也可置于 fixture 中。

### 缺失的抽象

将小段代码提取为辅助函数和类是由很多好处的：

1. 它增强了代码的表达力，潜在地消除了解释性注释需求。
2. 它提升了重用这些代码的机会，也有助于消除大量的重复代码。
3. 它使的接下来的测试更易于编写。

目前的测试需要三行代码来验证从 reader 中读取下一行的结果：

```cpp
TEST_F(LineReaderTest, OneLine) {
    LineReader reader(WriteTemporaryFile("a"));
    ASSERT_TRUE(reader.GetNextLine(&line, &len));
////////
    ASSERT_EQ(len, (unsigned)1);
    ASSERT_EQ(line[0], 'a');
    ASSERT_EQ(line[1], 0);
////////
    reader.PopLine(len);
    ASSERT_FALSE(reader.GetNextLine(&line, &len));
}
```

一个辅助函数可以将三个断言转为一个更加抽象的声明。甚至单元测试如果支持还可以自定义一个匹配断言器。

```cpp
void ASSERT_EQ_WITH_LENGTH(
const char* expected, const char* actual, unsigned length) {
    ASSERT_EQ(length, strlen(actual));
    ASSERT_STREQ(expected, actual);
}
TEST_F(LineReaderTest, OneLine) {
    LineReader reader(WriteTemporaryFile("a"));
    ASSERT_TRUE(reader.GetNextLine(&line, &len));
////////
    ASSERT_EQ_WITH_LENGTH("a", line, len);
////////
    reader.PopLine(len);
    ASSERT_FALSE(reader.GetNextLine(&line, &len));
}
```

### 多重断言

持续地审阅所有的测试名能够帮助你找到规范中的漏洞。

### 不相关的数据

测试中使用的数据有助于了解测试。内嵌在代码中的字面常量只会分散注意力，更糟糕的是，让人产生疑惑。如果一个函数调用需要参数，但这些参数与当前的测试无关，通常可以传入 0 或类似的数值来表示空（例如，字符串就用""表示）。对于阅读测试的人来说，这些数据应该提示“此数据无关”。（如果 0 是有意义的值，那就引入一个常量来帮助说明为什么。）

### 不必要的测试代码

有一些代码根本就不属于测试。本节讨论了一些可以从测试中完全移除的代码。

1. 断言不为空：
   - 段错误可不是好玩的。解引用空指针是不会有好结果的，剩余的测试会因为崩溃而无法运行。防御性的编程自然是一个可以理解的应对方案。

    ```cpp
    TEST_P(PersistenceTest, AddedItemCanBeRetrievedById)
    {
        persister->Add(*objectWithId1);
        auto found = persister->Get("1");
        ASSERT_THAT(found, NotNull());
        ASSERT_THAT(*found, Eq(*objectWithId1));
    }
    ```

    - 但是之所以设计测试，是为了驱动开发出常规行为或产生预想的失败，对于持久化的代码来说，已经由一个测试演示 Get() 会返回空 (Null)。一旦测试可以工作，就应该一直工作……除非未来某人的代码引入了一个缺陷或内存分配失败。因此，对空的检查（ASSERT_THAT(found, NotNull())）在此常规路径下不大可能失败。

    ```cpp
    TEST_P(PersistenceTest, ReturnsNullPointerWhenItemNotFound)
    {
        ASSERT_THAT(persister->Get("no id there"), IsNull());
    }
    ```

    - 可以移除这句多余的判空（ASSERT_THAT(found, NotNull())），缺点便是可能出现段错误。一些单元测试框架提供了另一种方法，该方案不需要一个额外代码行来验证指针。例如，Google Test提供了匹配器Pointee()。

    ```cpp
    TEST_P(PersistenceTest, AddedItemCanBeRetrievedById)
    {
        persister->Add(*objectWithId1);
        auto found = persister->Get("1");
        ASSERT_THAT(found, Pointee(*objectWithId1));
    }
    ```

    - 在做 TDD 时，想象一下在增量步伐中为指针为空检查编写一个断言。这样做没什么问题。但是，一旦你认为测试完成了，要回头看一下代码，消除一些不具有文档化意义的代码。通常而言，这类不必要的代码不仅仅只有指针为空检查的断言。

2. 异常处理
    - 如果开发的代码会产生异常，你需要编写一个测试来记录这个异常是怎么发生的。

    ```cpp
    TEST_F(BranchServiceTest, AddThrowsWhenNameNotUnique)
    {
        service.Add("samename", "");
        ASSERT_THROW(service.Add("samename", ""), DuplicateBranchNameException);
    }
    ```

    - 由于 add() 函数会抛出异常，一些程序员就想在调用 add() 的其他测试中做些保护措施。

    ```cpp
    TEST_F(BranchServiceTest, AddGeneratesUniqueId)
    {
        // 不要这样做！
        // 从不会产生异常的测试里去掉try/catch
        // 不会产生异常
        try
        {
            string id1 = service.Add("name1", "");
            string id2 = service.Add("name2", "");
            ASSERT_THAT(id1, Ne(id2));
        }
        catch (...) {
            FAIL();
        }
    }
    ```

    - **大部分测试是为了常规代码路径，它们是不会产生异常的。这些不必要的异常处理代码只会影响测试的可读性，并增加维护成本。**而测试已知异常流程时，请使用带有校验异常的断言，而不应该使用 try-catch 捕获。

3. 断言失败的消息
    - 带有消息的断言不能带来任何有价值的东西。就像正常的代码注释一样，应该尽量避免此类需求。如果一个断言不带失败消息就没意义的话，那么还是先解决测试中的其他问题吧！如果一个测试在测试集运行中意外失败了，也许不能从失败消息中立刻明确地看出原因。但通常要想找到导致失败的那行测试代码，需要得到所需信息。如果必要，可以加入临时的失败消息，然后再运行一遍。

4. 注释
    - 如果必须加注释来说明测试是做什么的，那你已经忘了测试文档化的要领。重写测试吧，专注于更好的命名和内聚。
    - 有些人觉得注释很有帮助，但注释不该将测试所做的（如果组织好的话就能清楚表明的）再说一遍。在保留测试表达力的前提下，努力找到一个去除注释的方法。对前一个测试而言，去除所有注释并不影响理解。

5. 隐含之意
    - “为什么测试这样断言其行为？”你可能希望，在不需要浪费时间分析测试或产品代码的前提下，测试阅读者就能够回答这个问题。
    - 通常来说，你会将实现细节从测试移至 SetUp() 或另一个辅助函数。**但注意，不要隐藏太多！**否则测试阅读者需要看得更深入才能知道答案。**合适的函数和变量名能使测试意图达到顾名思义的效果。**
    - 将期待的测试输出和测试上下文建立联系是一门艺术。你要时刻具有创造力。同时要提醒自己了解测试的内部细节，但其他人则不需要。

6. 误导性的组织
    - 一旦习惯了用Arrange-Act-Assert/Given-When-Then组织测试，你也会期待以此方式组织其他测试。而当看到组织方式与此不太一样的测试时，你的速度就会慢下来。因为你必须要努力弄清楚哪些是测试的设置、哪些是真正的功能，所以就不能立即理解测试。
    - 将执行语句分开，可以很清楚地看出测试的重点在 check-ins。进一步看这行代码，可以看出它涉及后来的 check-ins。了解了系统中哪些部分会参与其中，可以快速地转到测试的断言部分。
    - 在软件开发中，理解现有代码所花费的时间是众多大开销之一。你所做的每件小事都有助于降低此开销， AAA 的优点就是几乎不会带来任何开销。

7. 晦涩的命名
    - **在软件设计中，良好的命名是你可以做的最重要的事情之一。通常而言，好的名称是测试关联问题的解决方案。反之，如果不能赋予设计一个简洁的名称，很可能意味着该设计存在问题。**
    - 测试本身没什么不同。但如果一个测试的名称含糊不清或需要解释，那它就不能充当较好的文档。
